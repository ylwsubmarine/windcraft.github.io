<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Visual HTML Editor</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <link href="https://unpkg.com/aos@2.3.1/dist/aos.css" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
  <style>
    body {
      background-color: #f8fafc;
      font-family: 'Inter', sans-serif;
      margin: 0;
      color: #334155;
    }

    #content-frame {
      width: 100%;
      height: calc(100vh - 64px);
      border: none;
      background-color: white;
      box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
    }

    #editor-ui {
      display: none;
      position: fixed;
      inset: 0;
      background-color: #f8fafc;
      z-index: 10;
      overflow: hidden;
    }

    .glass-card {
      background: rgba(255, 255, 255, 0.95);
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 16px;
      transition: all 0.3s cubic-bezier(0.16, 1, 0.3, 1);
      box-shadow: 0 10px 25px rgba(0, 0, 0, 0.08);
    }

    @keyframes progress {
      0% { width: 0%; }
      100% { width: 100%; }
    }

    .animate-progress {
      animation: progress 2s cubic-bezier(0.16, 1, 0.3, 1);
    }

    .vhe-toolbar {
      position: absolute;
      background-color: rgba(255, 255, 255, 0.98);
      border: 1px solid rgba(203, 213, 225, 0.5);
      color: #334155;
      border-radius: 12px;
      padding: 6px;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.15), 0 1px 2px rgba(0, 0, 0, 0.05);
      z-index: 10000;
      display: none;
      transition: opacity 0.2s cubic-bezier(0.16, 1, 0.3, 1), transform 0.2s cubic-bezier(0.16, 1, 0.3, 1);
      backdrop-filter: blur(8px);
      -webkit-backdrop-filter: blur(8px);
      min-width: 50px;
      user-select: none;
      -webkit-user-select: none;
      -moz-user-select: none;
    }

    #block-toolbar {
      display: flex;
      gap: 4px;
      align-items: center;
    }

    #block-toolbar button {
      background-color: #f1f5f9;
      color: #475569;
      border: none;
      border-radius: 8px;
      padding: 8px;
      line-height: 1;
      font-size: 14px;
      transition: all 0.15s ease;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      height: 32px;
      width: 32px;
    }

    #block-toolbar button:hover {
      background-color: #e2e8f0;
      color: #0f172a;
      transform: translateY(-1px);
    }

    #block-toolbar button[data-action="delete"]:hover {
      background-color: #fee2e2;
      color: #dc2626;
    }

    #block-toolbar .vhe-toolbar-divider {
      margin-left: 4px;
      margin-right: 4px;
      height: 20px;
      border-left: 1px solid #cbd5e1;
      opacity: 0.5;
    }

    /* Color picker wrapper for consistency */
    .color-picker-wrapper {
      position: relative;
      width: 24px;
      height: 24px;
      margin: 4px;
      cursor: pointer;
    }

    /* Make color pickers circular */
    .block-color-picker {
      -webkit-appearance: none;
      -moz-appearance: none;
      appearance: none;
      width: 24px !important;
      height: 24px !important;
      border-radius: 50% !important;
      border: 1px solid rgba(0, 0, 0, 0.05) !important;
      overflow: hidden;
      cursor: pointer;
      padding: 0 !important;
      transition: all 0.15s ease;
      position: absolute;
      top: 0;
      left: 0;
    }

    .block-color-picker:hover {
      transform: scale(1.1);
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
    }

    /* Remove default color swatch border */
    .block-color-picker::-webkit-color-swatch-wrapper { padding: 0; }
    .block-color-picker::-webkit-color-swatch { border: none; border-radius: 50%; }
    .block-color-picker::-moz-color-swatch { border: none; border-radius: 50%; }

    /* Style the overlay icon */
    .color-picker-icon {
      position: absolute;
      top: 0;
      left: 0;
      width: 24px;
      height: 24px;
      display: flex;
      align-items: center;
      justify-content: center;
      pointer-events: none; /* Allow clicks to pass through to the input */
      color: rgba(255, 255, 255, 0.9);
      text-shadow: 0 0 2px rgba(0, 0, 0, 0.5);
      z-index: 1;
    }
    /* Specific icon styling for the (+) appearance */
    .color-picker-icon svg { stroke: rgba(0,0,0,0.3); }


    #element-toolbar {
      background-color: rgba(255, 255, 255, 0.98);
      color: #334155;
      padding: 16px;
      min-width: 280px;
      max-width: 380px;
      border: 1px solid rgba(203, 213, 225, 0.5);
      border-radius: 12px;
      max-height: 340px; /* UPDATED: Fixed max height */
      overflow: hidden;  /* Overall overflow hidden */
      display: flex;
      flex-direction: column; /* Stack header, tabs, content */
    }

    #element-toolbar-content {
      flex-grow: 1;         /* Take available vertical space below header/tabs */
      position: relative;   /* Context for absolute children */
      overflow: hidden;     /* Hide any overflow from this container */
      min-height: 0;        /* Help flex calculations */
    }

    /* The wrapper div generated by JS holding tab panes */
    #element-toolbar-content > #vhe-tab-content {
        position: absolute; /* Fill the parent (#element-toolbar-content) */
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        overflow: hidden; /* This wrapper shouldn't scroll */
    }


    /* Styles for individual tab content panes */
    #element-toolbar-content [data-tab-content] {
       height: 100%;        /* Fill the absolute parent (#vhe-tab-content) */
       overflow-y: auto;    /* Allow vertical scrolling *within* the pane */
       padding: 4px 12px 4px 4px; /* Add padding, esp. right for scrollbar */
       scrollbar-width: thin;
    }

    /* Ensure the 'hidden' class takes precedence */
    #element-toolbar-content [data-tab-content].hidden {
        display: none;
    }

    /* Scrollbar styles for tab content panes */
    #element-toolbar-content [data-tab-content]::-webkit-scrollbar {
      width: 6px;
    }
    #element-toolbar-content [data-tab-content]::-webkit-scrollbar-track {
      background: rgba(241, 245, 249, 0.5);
      border-radius: 10px;
      margin: 4px 0;
    }
    #element-toolbar-content [data-tab-content]::-webkit-scrollbar-thumb {
      background: rgba(203, 213, 225, 0.8);
      border-radius: 10px;
    }
    #element-toolbar-content [data-tab-content]::-webkit-scrollbar-thumb:hover {
      background: rgba(148, 163, 184, 0.8);
    }


    #element-toolbar button,
    #element-toolbar select,
    #element-toolbar input[type="text"] {
      font-size: 13px;
      margin: 1px;
      padding: 6px 8px;
      border: 1px solid #e2e8f0;
      border-radius: 8px;
      transition: all 0.15s ease;
    }

    #element-toolbar button { background-color: #f1f5f9; }
    #element-toolbar button:hover { background-color: #e2e8f0; transform: translateY(-1px); }

    #element-toolbar input[type="range"] {
      margin: 8px 0; height: 6px; width: 100%; border-radius: 3px; background: #e2e8f0; -webkit-appearance: none;
    }
    #element-toolbar input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none; width: 16px; height: 16px; border-radius: 50%; background: #6366f1; cursor: pointer; border: 2px solid white; box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
    }

    #element-toolbar .vhe-toolbar-group { margin-bottom: 10px; padding-bottom: 10px; border-bottom: 1px solid #f1f5f9; }
    #element-toolbar .vhe-toolbar-group:last-child { border-bottom: none; margin-bottom: 0; padding-bottom: 0; }
    #element-toolbar label { font-size: 12px; color: #64748b; display: block; margin-bottom: 3px; font-weight: 500; }

    #element-toolbar .vhe-toolbar-group div button[data-align] {
      padding: 8px; width: 36px; height: 36px; display: flex; align-items: center; justify-content: center;
    }

    /* General Swatch Styling in Element Toolbar */
    #element-toolbar .vhe-toolbar-group button[data-color-class],
    #element-toolbar .vhe-toolbar-group button[data-bg-color-class],
    #element-toolbar .vhe-toolbar-group button[data-hover-color-class], /* Deprecated for text */
    #element-toolbar .vhe-toolbar-group button[data-hover-text-color-value],
    #element-toolbar .vhe-toolbar-group button[data-hover-bg-color-value]
    {
      width: 24px; height: 24px; border-radius: 50%; transition: all 0.15s ease; border: 1px solid rgba(0, 0, 0, 0.05);
    }
    #element-toolbar .vhe-toolbar-group button[data-color-class]:hover,
    #element-toolbar .vhe-toolbar-group button[data-bg-color-class]:hover,
    #element-toolbar .vhe-toolbar-group button[data-hover-color-class]:hover,
    #element-toolbar .vhe-toolbar-group button[data-hover-text-color-value]:hover,
    #element-toolbar .vhe-toolbar-group button[data-hover-bg-color-value]:hover
    {
      transform: scale(1.1); box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
    }

    #element-toolbar button[data-action="clone-element"],
    #element-toolbar button[data-action="delete-element"] {
      padding: 5px 8px; background: none; border: none; border-radius: 6px; display: flex; align-items: center; justify-content: center;
    }
    #element-toolbar button[data-action="delete-element"]:hover { background-color: #fee2e2; color: #dc2626; }
    #element-toolbar button[data-action="clone-element"]:hover { background-color: #e0e7ff; color: #4338ca; }

    .vhe-tab-button { padding: 8px 12px; font-size: 13px; font-weight: 500; border-bottom: 2px solid transparent; margin-bottom: -1px; cursor: pointer; color: #64748b; transition: all 0.2s ease; }
    .vhe-tab-button:hover { color: #334155; }
    .vhe-tab-button.active { color: #6366f1; border-bottom-color: #6366f1; }

    .hidden { display: none; }

    /* Upload screen enhancements */
    #drop-zone { transition: all 0.3s cubic-bezier(0.16, 1, 0.3, 1); background: linear-gradient(to bottom right, rgba(255, 255, 255, 0.8), rgba(249, 250, 251, 0.8)); border: 2px dashed #cbd5e1; }
    #drop-zone:hover { border-color: #6366f1; background: linear-gradient(to bottom right, rgba(255, 255, 255, 0.9), rgba(243, 244, 246, 0.9)); transform: translateY(-2px); box-shadow: 0 10px 25px rgba(99, 102, 241, 0.1); }
    #browse-btn { transition: all 0.2s cubic-bezier(0.16, 1, 0.3, 1); background: linear-gradient(to right, #6366f1, #8b5cf6); border: none; font-weight: 500; letter-spacing: 0.01em; }
    #browse-btn:hover { transform: translateY(-1px); box-shadow: 0 4px 12px rgba(99, 102, 241, 0.2); background: linear-gradient(to right, #4f46e5, #7c3aed); }
    #progress-bar { background: linear-gradient(to right, #6366f1, #8b5cf6); transition: width 0.3s cubic-bezier(0.16, 1, 0.3, 1); border-radius: 999px; }

    /* Editor header enhancements */
    #save-btn { background: linear-gradient(to right, #6366f1, #8b5cf6); transition: all 0.2s cubic-bezier(0.16, 1, 0.3, 1); border: none; font-weight: 500; letter-spacing: 0.01em; }
    #save-btn:hover { transform: translateY(-1px); box-shadow: 0 4px 12px rgba(99, 102, 241, 0.2); background: linear-gradient(to right, #4f46e5, #7c3aed); }
    #undo-btn, #redo-btn, #preview-btn { transition: all 0.2s ease; border: 1px solid #e2e8f0; background-color: white; }
    #undo-btn:hover, #redo-btn:hover, #preview-btn:hover { background-color: #f8fafc; transform: translateY(-1px); }
    #undo-btn:disabled, #redo-btn:disabled { opacity: 0.5; cursor: not-allowed; transform: none; }

    /* Preview mode styles */
    .preview-mode #content-frame { z-index: 30; position: relative; }
    .preview-banner { display: none; position: fixed; top: 64px; left: 0; right: 0; background-color: rgba(79, 70, 229, 0.95); color: white; text-align: center; padding: 8px; z-index: 40; backdrop-filter: blur(4px); font-weight: 500; box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2); transition: transform 0.3s cubic-bezier(0.16, 1, 0.3, 1); }
    .preview-mode .preview-banner { display: block; }
    .preview-banner button { background-color: white; color: #4F46E5; border: none; padding: 4px 12px; border-radius: 4px; margin-left: 12px; font-weight: 500; cursor: pointer; transition: all 0.2s; }
    .preview-banner button:hover { background-color: #F9FAFB; transform: translateY(-1px); box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1); }

    /* Loading animation */
    @keyframes pulse { 0%, 100% { transform: scale(1); opacity: 1; } 50% { transform: scale(1.05); opacity: 0.8; } }
    .animate-pulse { animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite; }

    /* Block Animation styles */
    [data-vhe-block-id] { transition: transform 0.3s ease, opacity 0.3s ease; }
    .vhe-moving-up { transform: translateY(-10px); opacity: 0.85; }
    .vhe-moving-down { transform: translateY(10px); opacity: 0.85; }
    .vhe-duplicating { animation: vhe-duplicate-pulse 0.5s ease; }
    .vhe-deleting { animation: vhe-fade-out 0.3s ease forwards; }
    @keyframes vhe-duplicate-pulse { 0%, 100% { transform: scale(1); opacity: 1; } 50% { transform: scale(1.02); opacity: 0.9; } }
    @keyframes vhe-fade-out { 0% { transform: scale(1); opacity: 1; } 100% { transform: scale(0.98); opacity: 0; } }

    /* Element animation */
    [data-vhe-element-selected] { transition: outline 0.2s ease, box-shadow 0.2s ease, transform 0.3s ease, opacity 0.3s ease; }
    .vhe-element-moving { animation: vhe-element-move 0.4s ease; }
    .vhe-element-duplicating { animation: vhe-element-duplicate 0.4s ease; }
    .vhe-element-deleting { animation: vhe-element-delete 0.3s ease forwards; }
    @keyframes vhe-element-move { 0%, 100% { transform: translateY(0); } 50% { transform: translateY(5px); } }
    @keyframes vhe-element-duplicate { 0% { opacity: 0.5; transform: translateY(5px); } 100% { opacity: 1; transform: translateY(0); } }
    @keyframes vhe-element-delete { 0% { opacity: 1; transform: translateY(0); } 100% { opacity: 0; transform: translateY(5px); } }
  </style>
</head>
<body class="bg-gray-50">
  <!-- Upload Screen -->
  <div id="upload-screen" class="flex flex-col items-center justify-center min-h-screen bg-gradient-to-br from-indigo-50 via-slate-50 to-gray-50 p-4">
    <div class="max-w-xl w-full glass-card p-8 shadow-lg">
      <div class="text-center mb-8">
        <div class="flex items-center justify-center mb-3">
          <svg xmlns="http://www.w3.org/2000/svg" class="h-8 w-8 text-indigo-500 mr-2" viewBox="0 0 20 20" fill="currentColor">
            <path fill-rule="evenodd" d="M12.316 3.051a1 1 0 01.633 1.265l-4 12a1 1 0 11-1.898-.632l4-12a1 1 0 011.265-.633zM5.707 6.293a1 1 0 010 1.414L3.414 10l2.293 2.293a1 1 0 11-1.414 1.414l-3-3a1 1 0 010-1.414l3-3a1 1 0 011.414 0zm8.586 0a1 1 0 011.414 0l3 3a1 1 0 010 1.414l-3 3a1 1 0 11-1.414-1.414L16.586 10l-2.293-2.293a1 1 0 010-1.414z" clip-rule="evenodd" />
          </svg>
          <h1 class="text-3xl font-bold bg-clip-text text-transparent bg-gradient-to-r from-indigo-500 to-purple-600">Visual HTML Editor</h1>
        </div>
        <p class="text-gray-600">Upload HTML to edit visually - no coding required</p>
      </div>

      <div id="drop-zone" class="border-2 border-dashed border-gray-300 rounded-xl p-10 text-center mb-8 cursor-pointer hover:border-indigo-500 hover:bg-indigo-50 transition-all duration-300">
        <input type="file" id="file-input" accept=".html, .htm" class="hidden">
        <div class="mx-auto mb-4 text-indigo-500">
          <svg xmlns="http://www.w3.org/2000/svg" class="mx-auto h-16 w-16" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12" />
          </svg>
        </div>
        <p id="drop-zone-text" class="mb-2 text-base text-gray-700"><span class="font-semibold text-indigo-600">Drag & drop</span> your HTML file here</p>
        <p class="text-sm text-gray-500 mb-4">or</p>
        <button id="browse-btn" type="button" class="px-6 py-3 text-sm font-medium text-white bg-indigo-600 rounded-xl hover:bg-indigo-700 shadow-sm">Browse Files</button>
      </div>

      <div id="loading-indicator" class="hidden">
        <div class="text-center">
          <div class="mb-6 animate-pulse">
            <svg class="h-16 w-16 text-indigo-500 mx-auto" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
              <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
              <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
            </svg>
          </div>
          <h2 id="processing-stage" class="text-xl font-medium text-gray-900 mb-4">Processing your HTML</h2>
          <div class="w-full bg-gray-200 rounded-full h-3 mb-4 overflow-hidden">
            <div id="progress-bar" class="h-3 rounded-full animate-progress" style="width: 0%"></div>
          </div>
          <p class="text-sm text-gray-600">Please wait while we prepare your file for editing...</p>
        </div>
      </div>

      <p id="error-message" class="text-red-500 text-sm mt-4 hidden rounded-lg bg-red-50 p-3 border border-red-100"></p>

      <div class="bg-white rounded-xl shadow-sm border border-gray-100 p-5 mt-8">
        <h2 class="font-medium mb-3 flex items-center text-indigo-900">
          <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mr-2 text-indigo-500" viewBox="0 0 20 20" fill="currentColor">
            <path fill-rule="evenodd" d="M11.3 1.046A1 1 0 0112 2v5h4a1 1 0 01.82 1.573l-7 10A1 1 0 018 18v-5H4a1 1 0 01-.82-1.573l7-10a1 1 0 011.12-.38z" clip-rule="evenodd" />
          </svg>
          How it works:
        </h2>
        <ol class="text-sm text-gray-600 space-y-2 pl-8 list-decimal">
          <li class="pb-2">Upload your HTML file by dragging it into the drop zone or using the browse button</li>
          <li class="pb-2">Use the visual editor to make changes - no coding knowledge required</li>
          <li class="pb-2">Preview your page with all animations and scripts enabled</li>
          <li class="pb-2">Save your updated HTML file when you're done</li>
        </ol>
      </div>
    </div>
  </div>

  <!-- Editor UI -->
  <div id="editor-ui" class="hidden">
    <div class="bg-white shadow-md h-16 px-6 flex items-center justify-between z-20 relative border-b border-gray-200">
      <span class="text-lg font-semibold text-indigo-900 flex items-center">
        <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 mr-2 text-indigo-500" viewBox="0 0 20 20" fill="currentColor">
          <path fill-rule="evenodd" d="M12.316 3.051a1 1 0 01.633 1.265l-4 12a1 1 0 11-1.898-.632l4-12a1 1 0 011.265-.633zM5.707 6.293a1 1 0 010 1.414L3.414 10l2.293 2.293a1 1 0 11-1.414 1.414l-3-3a1 1 0 010-1.414l3-3a1 1 0 011.414 0zm8.586 0a1 1 0 011.414 0l3 3a1 1 0 010 1.414l-3 3a1 1 0 11-1.414-1.414L16.586 10l-2.293-2.293a1 1 0 010-1.414z" clip-rule="evenodd" />
        </svg>
        Visual Editor
      </span>
      <div class="flex items-center">
        <button id="undo-btn" class="bg-white hover:bg-gray-50 px-4 py-2 rounded-lg text-sm mr-2 flex items-center disabled:opacity-50 shadow-sm" disabled>
          <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 mr-1" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 19l-7-7m0 0l7-7m-7 7h18" />
          </svg>
          Undo
        </button>
        <button id="redo-btn" class="bg-white hover:bg-gray-50 px-4 py-2 rounded-lg text-sm mr-4 flex items-center disabled:opacity-50 shadow-sm" disabled>
          <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 mr-1" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M14 5l7 7m0 0l-7 7m7-7H3" />
          </svg>
          Redo
        </button>
        <button id="preview-btn" class="bg-white hover:bg-gray-50 px-4 py-2 rounded-lg text-sm mr-2 flex items-center shadow-sm border border-indigo-300">
          <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 mr-1 text-indigo-500" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 10l4.553-2.276A1 1 0 0121 8.618v6.764a1 1 0 01-1.447.894L15 14M5 18h8a2 2 0 002-2V8a2 2 0 00-2-2H5a2 2 0 00-2 2v8a2 2 0 002 2z" />
          </svg>
          Preview
        </button>
        <button id="save-btn" class="bg-indigo-600 hover:bg-indigo-700 text-white px-5 py-2 rounded-lg text-sm flex items-center shadow-sm">
          <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 mr-1" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 7H5a2 2 0 00-2 2v9a2 2 0 002 2h14a2 2 0 002-2V9a2 2 0 00-2-2h-3m-1 4l-3 3m0 0l-3-3m3 3V4" />
          </svg>
          Save & Export
        </button>
        <button id="close-editor-btn" title="Close Editor" class="ml-4 text-gray-400 hover:text-gray-600 p-2 rounded-full hover:bg-gray-100">
          <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
          </svg>
        </button>
      </div>
    </div>

    <div class="preview-banner">
      Preview Mode - Scripts and animations are enabled
      <button id="exit-preview-btn">Exit Preview</button>
    </div>

    <iframe id="content-frame" title="Editable Content" sandbox="allow-same-origin allow-scripts"></iframe>

    <div id="block-toolbar" class="vhe-toolbar items-center">
      <button data-action="move-up" title="Move Up">
        <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 10l7-7m0 0l7 7m-7-7v18" />
        </svg>
      </button>
      <button data-action="move-down" title="Move Down">
        <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 14l-7 7m0 0l-7-7m7 7V3" />
        </svg>
      </button>
      <button data-action="duplicate" title="Duplicate Block">
        <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 7v8a2 2 0 002 2h6M8 7V5a2 2 0 012-2h4.586a1 1 0 01.707.293l4.414 4.414a1 1 0 01.293.707V15a2 2 0 01-2 2h-2M8 7H6a2 2 0 00-2 2v10a2 2 0 002 2h8a2 2 0 002-2v-2" />
        </svg>
      </button>
      <button data-action="delete" title="Delete Block">
        <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" />
        </svg>
      </button>
      <div class="vhe-toolbar-divider mx-1 h-4 self-center border-l border-gray-300 opacity-50"></div>
      <div class="color-picker-wrapper" title="Block Background Color">
        <label for="vhe-block-bg-color-picker" class="sr-only">Background Color</label>
        <input type="color" id="vhe-block-bg-color-picker" class="block-color-picker">
        <div class="color-picker-icon">
          <svg xmlns="http://www.w3.org/2000/svg" width="10" height="10" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round">
            <path d="M12 2v8"></path><path d="M12 22v-8"></path><path d="M2 12h8"></path><path d="M22 12h-8"></path>
          </svg>
        </div>
      </div>
    </div>

    <div id="element-toolbar" class="vhe-toolbar">
      <button id="close-element-toolbar" title="Close" class="absolute top-2 right-2 text-gray-400 hover:text-gray-600 p-1 rounded-full hover:bg-gray-100">
        <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
        </svg>
      </button>
      <div id="element-toolbar-content"></div> <!-- Content dynamically generated -->
    </div>
  </div>

  <script>
    // --- State & Refs ---
    let iframe = null; let iframeDoc = null; let iframeWin = null; let selectedElement = null; let hoveredElement = null; let hoveredBlock = null; let history = []; let historyIndex = -1; let currentContentLoading = false; const MAX_HISTORY = 50; const EDITOR_HEADER_HEIGHT = 64; const TOOLBAR_OFFSET = 5; let hideToolbarTimer = null; let isColorPickerActive = false; let isPreviewMode = false;
    let uploadScreen, editorUi, fileInput, dropZone, dropZoneText, loadingIndicator, errorMessage, contentFrame, saveBtn, undoBtn, redoBtn, closeEditorBtn, blockToolbar, elementToolbar, elementToolbarContent, closeElementToolbarBtn, browseBtn, progressBar, processingStage, previewBtn, previewBanner, exitPreviewBtn; let elementScrollListener = null;

    // --- Text Toolbar Constants ---
    const PREDEFINED_COLORS = [ { name: 'Black', value: '#000000', class: 'text-black' }, { name: 'White', value: '#FFFFFF', class: 'text-white' }, { name: 'Gray-500', value: '#6B7280', class: 'text-gray-500' }, { name: 'Red-500', value: '#EF4444', class: 'text-red-500' }, { name: 'Blue-500', value: '#3B82F6', class: 'text-blue-500' }, { name: 'Green-500', value: '#22C55E', class: 'text-green-500' }, ];
    const PREDEFINED_BG_COLORS = [ { name: 'Transparent', value: 'transparent', class: 'bg-transparent' }, { name: 'White', value: '#FFFFFF', class: 'bg-white' }, { name: 'Black', value: '#000000', class: 'bg-black' }, { name: 'Gray-500', value: '#6B7280', class: 'bg-gray-500' }, { name: 'Indigo-600', value: '#4F46E5', class: 'bg-indigo-600' }, { name: 'Red-500', value: '#EF4444', class: 'bg-red-500' } ];
    const FONT_FACES = [ "Current", "Roboto", "Open Sans", "Georgia", "Inter", "Oswald", "Bebas Neue" ];
    const FONT_WEIGHTS = { 'Light': 'font-light', 'Normal': 'font-normal', 'Medium': 'font-medium', 'Semibold': 'font-semibold', 'Bold': 'font-bold', 'Extrabold': 'font-extrabold' };
    const FONT_WEIGHT_CLASSES = Object.values(FONT_WEIGHTS);
    const TEXT_ALIGN_CLASSES = ['text-left', 'text-center', 'text-right', 'text-justify'];
    const TEXT_COLOR_CLASSES_REGEX = /^text-(?:black|white|inherit|current|transparent|slate|gray|zinc|neutral|stone|red|orange|amber|yellow|lime|green|emerald|teal|cyan|sky|blue|indigo|violet|purple|fuchsia|pink|rose)(?:-(?:50|[1-9]00))?$/;
    const BG_COLOR_CLASSES_REGEX = /^bg-(?:inherit|current|transparent|black|white|slate|gray|zinc|neutral|stone|red|orange|amber|yellow|lime|green|emerald|teal|cyan|sky|blue|indigo|violet|purple|fuchsia|pink|rose)(?:-(?:50|[1-9]00))?$/;
    const BG_GRADIENT_CLASSES_REGEX = /^bg-gradient-to-/;
    const HOVER_TEXT_COLOR_CLASSES_REGEX = /^hover:text-(?:black|white|inherit|current|transparent|slate|gray|zinc|neutral|stone|red|orange|amber|yellow|lime|green|emerald|teal|cyan|sky|blue|indigo|violet|purple|fuchsia|pink|rose)(?:-(?:50|[1-9]00))?$/;
    const HOVER_BG_COLOR_CLASSES_REGEX = /^hover:bg-(?:inherit|current|transparent|black|white|slate|gray|zinc|neutral|stone|red|orange|amber|yellow|lime|green|emerald|teal|cyan|sky|blue|indigo|violet|purple|fuchsia|pink|rose)(?:-(?:50|[1-9]00))?$/;
    const DEFAULT_HOVER_DURATION = '0.2s';

    // --- Initialization ---
    document.addEventListener('DOMContentLoaded', () => {
      uploadScreen = document.getElementById('upload-screen'); editorUi = document.getElementById('editor-ui'); fileInput = document.getElementById('file-input'); dropZone = document.getElementById('drop-zone'); dropZoneText = document.getElementById('drop-zone-text'); loadingIndicator = document.getElementById('loading-indicator'); errorMessage = document.getElementById('error-message'); contentFrame = document.getElementById('content-frame'); saveBtn = document.getElementById('save-btn'); undoBtn = document.getElementById('undo-btn'); redoBtn = document.getElementById('redo-btn'); closeEditorBtn = document.getElementById('close-editor-btn'); blockToolbar = document.getElementById('block-toolbar'); elementToolbar = document.getElementById('element-toolbar'); elementToolbarContent = document.getElementById('element-toolbar-content'); closeElementToolbarBtn = document.getElementById('close-element-toolbar'); browseBtn = document.getElementById('browse-btn'); progressBar = document.getElementById('progress-bar'); processingStage = document.getElementById('processing-stage'); previewBtn = document.getElementById('preview-btn'); previewBanner = document.querySelector('.preview-banner'); exitPreviewBtn = document.getElementById('exit-preview-btn'); iframe = contentFrame;
      if (!blockToolbar || !elementToolbar || !iframe) { console.error("CRITICAL: Missing essential UI elements."); alert("Editor init failed."); return; } console.log("All essential elements found.");
      setupUploadListeners(); if (saveBtn) saveBtn.addEventListener('click', saveAndExportHtml); if (undoBtn) undoBtn.addEventListener('click', undo); if (redoBtn) redoBtn.addEventListener('click', redo); if (closeEditorBtn) closeEditorBtn.addEventListener('click', closeEditor); if (closeElementToolbarBtn) closeElementToolbarBtn.addEventListener('click', hideElementToolbar);
      if (previewBtn) previewBtn.addEventListener('click', togglePreviewMode);
      if (exitPreviewBtn) exitPreviewBtn.addEventListener('click', exitPreviewMode);
      // Block Toolbar Listeners
      if (blockToolbar) { blockToolbar.addEventListener('click', (event) => { const button = event.target.closest('button[data-action]'); if (!button || !blockToolbar._targetBlock) return; const action = button.dataset.action; const targetBlock = blockToolbar._targetBlock; try { switch (action) { case 'move-up': if (moveBlock(targetBlock, 'up')) { setTimeout(() => { if (document.contains(targetBlock) && hoveredBlock === targetBlock) { showBlockToolbar(targetBlock); } else { hideBlockToolbar(); } }, 10); } break; case 'move-down': if (moveBlock(targetBlock, 'down')) { setTimeout(() => { if (document.contains(targetBlock) && hoveredBlock === targetBlock) { showBlockToolbar(targetBlock); } else { hideBlockToolbar(); } }, 10); } break; case 'duplicate': duplicateBlock(targetBlock); break; case 'delete': deleteBlock(targetBlock); break; } } catch (error) { console.error(`Error in block action "${action}":`, error); alert(`Error: ${error.message}`); hideBlockToolbar(); } });
        blockToolbar.addEventListener('mouseenter', () => { if (hideToolbarTimer) { clearTimeout(hideToolbarTimer); hideToolbarTimer = null; } });
        blockToolbar.addEventListener('mouseleave', () => { requestHideToolbar(); });
      }
      // Block BG Color Picker Listeners
      const blockBgColorPicker = document.getElementById('vhe-block-bg-color-picker');
      if (blockBgColorPicker) {
          blockBgColorPicker.addEventListener('input', (event) => { if (blockToolbar && blockToolbar._targetBlock) { applyInlineStyle(blockToolbar._targetBlock, 'backgroundColor', event.target.value); } });
          blockBgColorPicker.addEventListener('click', () => { isColorPickerActive = true; if (hideToolbarTimer) { clearTimeout(hideToolbarTimer); hideToolbarTimer = null; } });
          blockBgColorPicker.addEventListener('change', () => { isColorPickerActive = false; if (blockToolbar && blockToolbar._targetBlock) { addHistorySnapshot(`Set block background to ${blockBgColorPicker.value}`); } requestHideToolbar(50); });
          blockBgColorPicker.addEventListener('blur', () => { setTimeout(() => { isColorPickerActive = false; requestHideToolbar(100); }, 150); });
      } else { console.error("Block BG picker not found!"); }
    });

    // --- File Handling ---
    function setupUploadListeners() { if(browseBtn) browseBtn.addEventListener('click', () => { fileInput?.click(); }); if(dropZone) dropZone.addEventListener('click', (event) => { if (browseBtn && (event.target === browseBtn || browseBtn.contains(event.target))) return; fileInput?.click(); }); if(fileInput) fileInput.addEventListener('change', handleFileSelect); if(dropZone) { dropZone.addEventListener('dragover', handleDragOver); dropZone.addEventListener('dragleave', handleDragLeave); dropZone.addEventListener('drop', handleDrop); } }
    function handleFileSelect(event) { const file = event.target.files?.[0]; if (file) processFile(file); }
    function handleDragOver(event) { event.preventDefault(); event.stopPropagation(); dropZone?.classList.add('border-indigo-500', 'bg-indigo-50'); if(dropZoneText) dropZoneText.textContent = "Drop file"; }
    function handleDragLeave(event) { event.preventDefault(); event.stopPropagation(); resetDropZone(); }
    function handleDrop(event) { event.preventDefault(); event.stopPropagation(); resetDropZone(); const file = event.dataTransfer?.files?.[0]; if (file) processFile(file); }
    function resetDropZone() { dropZone?.classList.remove('border-indigo-500', 'bg-indigo-50'); if(dropZoneText) dropZoneText.innerHTML = '<span class="font-semibold text-indigo-600">Drag & drop</span> your HTML file here'; }
    function processFile(file) { if (!file || currentContentLoading) return; if (!file.type.match('text/html') && !file.name.endsWith('.html') && !file.name.endsWith('.htm')) { showError("Invalid file type. Please upload an HTML file."); return; } showLoading(true); showError(''); currentContentLoading = true; const reader = new FileReader(); reader.onload = async (e) => { try { const content = e.target?.result; if (typeof content !== 'string') throw new Error("FileReader error."); console.log("File read, length:", content.length); updateProgress(20,"Analyzing"); await new Promise(r=>setTimeout(r,20)); updateProgress(40,"Preparing"); await new Promise(r=>setTimeout(r,20)); resetEditorState(); updateProgress(60,"Setting up"); await new Promise(r=>setTimeout(r,20)); updateProgress(80,"Loading"); await new Promise(r=>setTimeout(r,20)); loadContentIntoIframe(content); } catch (error) { console.error("Error processing file:", error); showError("Failed to process file: "+error.message); showLoading(false); currentContentLoading = false; closeEditor(); } }; reader.onerror = (error) => { console.error("FileReader error:", error); showError("Could not read file."); showLoading(false); currentContentLoading = false; }; reader.readAsText(file); }
    function updateProgress(percent, message) { if(progressBar) progressBar.style.width = `${percent}%`; if(processingStage) processingStage.textContent = message || "Processing"; }
    function showLoading(isLoading) { if(loadingIndicator) loadingIndicator.style.display = isLoading ? 'block' : 'none'; if(dropZone) dropZone.style.display = isLoading ? 'none' : 'block'; if(browseBtn) browseBtn.style.display = isLoading ? 'none' : 'inline-block'; if (!isLoading) resetDropZone(); }
    function showError(message) { if(errorMessage) { errorMessage.textContent = message; errorMessage.style.display = message ? 'block' : 'none'; } }
    function resetEditorState() { console.log("Resetting state..."); if (iframeDoc) { iframeDoc.body?.removeEventListener('mouseover', handleIframeMouseOver); iframeDoc.body?.removeEventListener('mouseout', handleIframeMouseOut); iframeDoc.body?.removeEventListener('click', handleIframeClick, true); iframeDoc.body?.removeEventListener('dblclick', handleIframeDoubleClick); } if (iframeWin) { iframeWin.removeEventListener('blur', handleIframeBlur, true); if (elementScrollListener) { iframeWin.removeEventListener('scroll', elementScrollListener); elementScrollListener = null; } } if (iframe) { iframe.removeAttribute('srcdoc'); iframe.onload = null; iframe.onerror = null; } iframeDoc=null; iframeWin=null; selectedElement=null; hoveredElement=null; hoveredBlock=null; history=[]; historyIndex=-1; isPreviewMode=false; if (editorUi) editorUi.classList.remove('preview-mode'); updateUndoRedoState(); hideBlockToolbar(); hideElementToolbar(); isColorPickerActive = false; if(hideToolbarTimer) clearTimeout(hideToolbarTimer); hideToolbarTimer = null; }
    function closeEditor() { console.log("Closing editor..."); resetEditorState(); if (iframe) iframe.src = 'about:blank'; if (editorUi) editorUi.style.display = 'none'; if (uploadScreen) uploadScreen.style.display = 'flex'; resetDropZone(); showLoading(false); showError(''); currentContentLoading = false; if(fileInput) fileInput.value = ''; }

    // --- Iframe Loading & Instrumentation ---
    function loadContentIntoIframe(htmlContent) {
      if (!iframe) { console.error("No iframe."); showError("Editor init failed: iframe missing."); showLoading(false); currentContentLoading = false; return; }
      iframe.onload = null; iframe.onerror = null; let successfullyInstrumented = false;
      iframe.onload = () => {
        if (!currentContentLoading || successfullyInstrumented) return;
        try {
          iframeDoc = iframe.contentDocument; iframeWin = iframe.contentWindow;
          if (!iframeDoc || !iframeWin) throw new Error("Cannot access iframe content.");
          iframeWin.requestAnimationFrame(() => {
            if (!iframeDoc.body) throw new Error("Iframe body not found."); console.log("Attempting instrumentation...");
            successfullyInstrumented = instrumentIframeContent();
            if (successfullyInstrumented) {
              console.log("Instrumentation started (async)...");
              addInitialHistorySnapshot(); updateUndoRedoState();
              if(uploadScreen) uploadScreen.style.display = 'none'; if(editorUi) editorUi.style.display = 'block'; if(iframe) iframe.style.height = `calc(100vh - ${EDITOR_HEADER_HEIGHT}px)`;
            } else { throw new Error("Instrumentation setup failed."); }
            showLoading(false); currentContentLoading = false;
          });
        } catch (error) { console.error("Error iframe onload/instrumentation setup:", error); showError(`Load failed: ${error.message}`); closeEditor(); showLoading(false); currentContentLoading = false; }
      };
      iframe.onerror = (err) => { console.error("Iframe loading error:", err); showError("Failed to load HTML."); closeEditor(); showLoading(false); currentContentLoading = false; };
      iframe.srcdoc = htmlContent;
    }

    function instrumentIframeContent() {
      if (!iframeDoc || !iframeWin || !iframeDoc.body) { console.error(`Instrumentation aborted: iframe missing.`); currentContentLoading = false; return false; }
      try {
        iframeDoc.querySelectorAll('script').forEach(script => { script.setAttribute('type', 'text/disabled-javascript'); script.setAttribute('data-vhe-disabled', 'true'); });
        let disableAnimationsStyle = iframeDoc.head.querySelector('style[data-vhe-disable-animations]');
        if (!disableAnimationsStyle) {
          disableAnimationsStyle = iframeDoc.createElement('style'); disableAnimationsStyle.setAttribute('data-vhe-disable-animations', 'true');
          disableAnimationsStyle.textContent = `
            *:not([data-vhe-element-id]) {
              animation: none !important;
              animation-iteration-count: 1 !important;
              animation-duration: 0s !important;
            }
             [data-vhe-element-id] {
                 transition-property: color, background-color !important;
                 transition-timing-function: ease !important;
             }
          `;
          iframeDoc.head.appendChild(disableAnimationsStyle);
        }
        let style = iframeDoc.head.querySelector('style[data-vhe-styles]');
        if (!style) {
          style = iframeDoc.createElement('style'); style.dataset.vheStyles = 'true';
          style.textContent = ` [data-vhe-block-hover], [data-vhe-element-hover], [data-vhe-element-selected], [contenteditable="true"]:focus { position: relative !important; z-index: 9990 !important; } [data-vhe-block-hover] { outline: 2px dashed rgba(99, 102, 241, 0.6) !important; outline-offset: 2px; border-radius: 2px; box-shadow: 0 0 0 2px rgba(99, 102, 241, 0.2); cursor: default; transition: outline 0.1s, box-shadow 0.1s;} [data-vhe-element-hover] { outline: 1px dashed #8B5CF6 !important; outline-offset: 1px; cursor: pointer; transition: outline 0.1s; z-index: 9991 !important; } [data-vhe-element-selected] { outline: 2px solid #8B5CF6 !important; outline-offset: 2px; box-shadow: 0 0 0 4px rgba(139, 92, 246, 0.3); transition: outline 0.1s, box-shadow 0.1s; z-index: 9992 !important; } [contenteditable="true"]:focus { outline: 2px solid #facc15 !important; box-shadow: 0 0 0 4px rgba(250, 204, 21, 0.3); z-index: 9993 !important; } `;
          iframeDoc.head.appendChild(style);
        }
        if (!iframeDoc.getElementById('vhe-google-fonts-link')) {
          const fontFamiliesToLoad = FONT_FACES.filter(f => f !== "Current").map(f => f.replace(/\s/g, '+'));
          const weights = '300;400;500;700;800';
          const familiesQuery = fontFamiliesToLoad.map(f => `family=${f}:wght@${weights}`).join('&');
          if (familiesQuery) {
            const fontLink = iframeDoc.createElement('link'); fontLink.id = 'vhe-google-fonts-link'; fontLink.rel = 'stylesheet'; fontLink.href = `https://fonts.googleapis.com/css2?${familiesQuery}&display=swap`;
            iframeDoc.head.appendChild(fontLink); console.log("Fonts injected.");
          }
        }
        iframeDoc.querySelectorAll('[data-vhe-element-id]').forEach(el => {
            const hoverTextColor = el.style.getPropertyValue('--vhe-hover-text-color');
            const hoverBgColor = el.style.getPropertyValue('--vhe-hover-bg-color');
            const hoverDuration = el.style.getPropertyValue('--vhe-hover-duration');
            if (hoverTextColor || hoverBgColor || hoverDuration) { updateHoverStyleTag(el, hoverTextColor, hoverBgColor, hoverDuration); }
        });
        setTimeout(() => {
          try {
            console.log("Resetting fixed/sticky..."); let resetCount = 0;
            const fixedCandidates = iframeDoc.querySelectorAll('header, nav');
            fixedCandidates.forEach(el => { try { const computedStyle = iframeWin.getComputedStyle(el); if (computedStyle.position === 'fixed' || computedStyle.position === 'sticky') { el.style.setProperty('position', 'relative', 'important'); el.style.setProperty('top', 'auto', 'important'); el.style.setProperty('left', 'auto', 'important'); el.style.setProperty('right', 'auto', 'important'); el.style.setProperty('bottom', 'auto', 'important'); el.style.setProperty('z-index', 'auto', 'important'); resetCount++; } } catch (e) { console.warn("Err resetting fixed:", el, e); } });
            console.log(`Reset ${resetCount} fixed/sticky.`); let blockCount = 0;
            const potentialBlocks = iframeDoc.body.querySelectorAll('div, section, article, header, footer, main, aside, nav, form, table, ul, ol, figure');
            potentialBlocks.forEach((el, index) => { if (el && el.nodeType === Node.ELEMENT_NODE && !['SCRIPT', 'STYLE', 'TEMPLATE', 'LINK', 'META'].includes(el.tagName) && !el.dataset.vheBlockId) { try { const computedStyle = iframeWin.getComputedStyle(el); const minHeight = 20; const hasBlockLayout = ['block', 'flex', 'grid'].includes(computedStyle.display); const isSemanticBlock = ['SECTION', 'ARTICLE', 'HEADER', 'FOOTER', 'NAV', 'ASIDE', 'MAIN', 'FIGURE'].includes(el.tagName); const isTallEnough = el.offsetHeight > minHeight; const isWideEnough = el.offsetWidth > minHeight; if (isTallEnough && isWideEnough && (hasBlockLayout || isSemanticBlock) ) { if (!el.parentElement?.dataset.vheBlockId) { el.dataset.vheBlockId = `vhe-block-${index}-${Date.now()}`; blockCount++; } } } catch (e) { } } });
            console.log(`Finished block IDs: ${blockCount}`);
            iframeDoc.body.removeEventListener('mouseover', handleIframeMouseOver); iframeDoc.body.removeEventListener('mouseout', handleIframeMouseOut); iframeDoc.body.removeEventListener('click', handleIframeClick, true); iframeDoc.body.removeEventListener('dblclick', handleIframeDoubleClick); iframeWin.removeEventListener('blur', handleIframeBlur, true);
            iframeDoc.body.addEventListener('mouseover', handleIframeMouseOver); iframeDoc.body.addEventListener('mouseout', handleIframeMouseOut); iframeDoc.body.addEventListener('click', handleIframeClick, true); iframeDoc.body.addEventListener('dblclick', handleIframeDoubleClick); iframeWin.addEventListener('blur', handleIframeBlur, true);
          } catch(delayedError) { console.error("Error during delayed instrumentation:", delayedError); showError("Failed post-load setup."); }
        }, 100);
        return true;
      } catch (error) { console.error("Error starting instrumentation:", error); return false; }
    }

    // --- Preview Mode Functions ---
    function togglePreviewMode() { if (isPreviewMode) { exitPreviewMode(); } else { enterPreviewMode(); } }
    function enterPreviewMode() {
      if (isPreviewMode || currentContentLoading) return; isPreviewMode = true; currentContentLoading = true;
      const currentHtml = getCurrentHTML();
      clearElementSelection(); hideElementToolbar(); hideBlockToolbar(); editorUi.classList.add('preview-mode');
      if (previewBtn) { previewBtn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 mr-1 text-indigo-500" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15.232 5.232l3.536 3.536m-2.036-5.036a2.5 2.5 0 113.536 3.536L6.5 21.036H3v-3.572L16.732 3.732z" /></svg> Edit Mode`; }
      loadPreviewContent(currentHtml); console.log("Entered preview mode");
    }
    function exitPreviewMode() {
      if (!isPreviewMode || currentContentLoading) return; currentContentLoading = true; isPreviewMode = false;
      let htmlToRestore = '';
      if (history.length > 0 && historyIndex >= 0) { htmlToRestore = history[historyIndex].html; console.log("Exiting preview: Restoring from history index", historyIndex); }
      else { console.error("Cannot exit preview: History is empty."); alert("Error exiting preview mode. Please reload."); currentContentLoading = false; return; }
      editorUi.classList.remove('preview-mode');
      if (previewBtn) { previewBtn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 mr-1 text-indigo-500" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 10l4.553-2.276A1 1 0 0121 8.618v6.764a1 1 0 01-1.447.894L15 14M5 18h8a2 2 0 002-2V8a2 2 0 00-2-2H5a2 2 0 00-2 2v8a2 2 0 002 2z" /></svg> Preview`; }
      restoreHistoryState(historyIndex); console.log("Exited preview mode");
    }
    function loadPreviewContent(htmlContent) {
      if (!iframe) { console.error("No iframe for preview"); currentContentLoading = false; return; }
      iframe.onload = null; iframe.onerror = null; const previewHtml = htmlContent;
      iframe.onload = () => {
        console.log("Preview content loaded");
        try {
          iframeDoc = iframe.contentDocument; iframeWin = iframe.contentWindow;
          if (!iframeDoc || !iframeWin) { throw new Error("Cannot access iframe content in preview mode"); }
          iframe.style.height = `calc(100vh - ${EDITOR_HEADER_HEIGHT}px)`;
          currentContentLoading = false;
        } catch (error) { console.error("Error in preview mode setup:", error); alert("Preview mode error: " + error.message); currentContentLoading = false; }
      };
      iframe.onerror = (err) => { console.error("Preview iframe loading error:", err); alert("Failed to load preview"); currentContentLoading = false; };
      iframe.srcdoc = previewHtml;
    }

    function getCurrentHTML() {
      if (!iframeDoc || !iframeDoc.documentElement) { console.error("No iframe document"); return ""; }
      try {
        const tempDoc = iframeDoc.cloneNode(true); let generatedHoverStyles = ''; let hoverClassCounter = 0;
        tempDoc.querySelectorAll('[data-vhe-element-id]').forEach(el => {
          const hoverTextColor = el.style.getPropertyValue('--vhe-hover-text-color'); const hoverBgColor = el.style.getPropertyValue('--vhe-hover-bg-color'); const hoverDuration = el.style.getPropertyValue('--vhe-hover-duration') || DEFAULT_HOVER_DURATION;
          if (hoverTextColor || hoverBgColor) {
            hoverClassCounter++; const uniqueClassName = `vhe-hover-fx-${hoverClassCounter}`; el.classList.add(uniqueClassName);
            let transitionProperties = []; let hoverProperties = '';
            if (hoverTextColor) { transitionProperties.push('color'); hoverProperties += ` color: ${hoverTextColor} !important;`; }
            if (hoverBgColor) { transitionProperties.push('background-color'); hoverProperties += ` background-color: ${hoverBgColor} !important;`; }
            generatedHoverStyles += `
              .${uniqueClassName} { transition-property: ${transitionProperties.join(', ')} !important; transition-duration: ${hoverDuration} !important; transition-timing-function: ease !important; }
              .${uniqueClassName}:hover { ${hoverProperties} }
            `;
          } else if (el.style.getPropertyValue('--vhe-hover-duration')) {
             const hasTWTextHover = Array.from(el.classList).some(cls => HOVER_TEXT_COLOR_CLASSES_REGEX.test(cls)); const hasTWBGHover = Array.from(el.classList).some(cls => HOVER_BG_COLOR_CLASSES_REGEX.test(cls));
             if(hasTWTextHover || hasTWBGHover){
                 hoverClassCounter++; const uniqueClassName = `vhe-hover-fx-${hoverClassCounter}`; el.classList.add(uniqueClassName);
                 let transitionProperties = []; if(hasTWTextHover) transitionProperties.push('color'); if(hasTWBGHover) transitionProperties.push('background-color');
                 generatedHoverStyles += ` .${uniqueClassName} { transition-property: ${transitionProperties.join(', ')} !important; transition-duration: ${hoverDuration} !important; transition-timing-function: ease !important; } `;
             }
          }
          delete el.dataset.vheElementId; el.style.removeProperty('--vhe-hover-text-color'); el.style.removeProperty('--vhe-hover-bg-color'); el.style.removeProperty('--vhe-hover-duration');
        });
        tempDoc.querySelectorAll('[data-vhe-block-id],[data-vhe-block-hover],[data-vhe-element-hover],[data-vhe-element-selected],[data-original-html],[contenteditable="true"],[data-vhe-link-wrapper]').forEach(el => {
          delete el.dataset.vheBlockId; delete el.dataset.vheBlockHover; delete el.dataset.vheElementHover; delete el.dataset.vheElementSelected; delete el.dataset.originalHtml; delete el.dataset.vheLinkWrapper; el.removeAttribute('contenteditable');
        });
        tempDoc.head?.querySelector('style[data-vhe-styles]')?.remove(); tempDoc.head?.querySelector('style[data-vhe-disable-animations]')?.remove(); tempDoc.head?.querySelector('#vhe-google-fonts-link')?.remove(); tempDoc.head?.querySelectorAll('style[id^="vhe-hover-style-"]')?.forEach(style => style.remove());
        if (generatedHoverStyles) { const hoverStyleSheet = tempDoc.createElement('style'); hoverStyleSheet.id = 'vhe-generated-hover-styles'; hoverStyleSheet.textContent = generatedHoverStyles; tempDoc.head.appendChild(hoverStyleSheet); }
        tempDoc.querySelectorAll('script[type="text/disabled-javascript"][data-vhe-disabled="true"]').forEach(script => { script.setAttribute('type', 'text/javascript'); script.removeAttribute('data-vhe-disabled'); });
        const doctypeString = iframeDoc.doctype ? new XMLSerializer().serializeToString(iframeDoc.doctype) : "<!DOCTYPE html>";
        return doctypeString + "\n" + tempDoc.documentElement.outerHTML;
      } catch (error) { console.error("Error getting current HTML:", error); return ""; }
    }

    // --- Event Handlers ---
    function handleIframeMouseOver(event) { if (!iframeDoc || currentContentLoading || isPreviewMode) return; const target = event.target; if (blockToolbar?.contains(target)) { if (hideToolbarTimer) { clearTimeout(hideToolbarTimer); hideToolbarTimer = null; } return; } if (!target || target === iframeDoc.body || target === iframeDoc.documentElement) { clearElementHover(); if(hoveredBlock) requestHideToolbar(); return; }; const targetEditable = target.closest('p,h1,h2,h3,h4,h5,h6,button,a,img,div,span,li,td,th,strong,em,b,i'); if (targetEditable && isEditableElement(targetEditable)) { if (targetEditable !== hoveredElement) { clearElementHover(); targetEditable.dataset.vheElementHover = 'true'; hoveredElement = targetEditable; } } else if (hoveredElement) { clearElementHover(); } const targetBlock = target.closest('[data-vhe-block-id]'); if (targetBlock) { if (targetBlock !== hoveredBlock) { clearBlockHover(); targetBlock.dataset.vheBlockHover = 'true'; hoveredBlock = targetBlock; } if (hideToolbarTimer) { clearTimeout(hideToolbarTimer); hideToolbarTimer = null; } showBlockToolbar(targetBlock); } }
    function handleIframeMouseOut(event) { if (!iframeDoc || currentContentLoading || isPreviewMode) return; const relatedTarget = event.relatedTarget; const isLeavingIframe = !relatedTarget || relatedTarget.ownerDocument !== iframeDoc; const isMovingToToolbar = blockToolbar?.contains(relatedTarget); if (hoveredElement && (!relatedTarget || !hoveredElement.contains(relatedTarget))) { clearElementHover(); } if (hoveredBlock && !hoveredBlock.contains(relatedTarget) && !isMovingToToolbar) { requestHideToolbar(); } else if(isLeavingIframe) { requestHideToolbar(); } }
    function handleIframeClick(event) { if (!iframeDoc || currentContentLoading || isPreviewMode) return; const target = event.target; const linkWrapper = target.closest('a[data-vhe-link-wrapper="true"]'); if (target.closest('a') && !linkWrapper) { event.preventDefault(); }
      if (blockToolbar?.contains(target) || elementToolbar?.contains(target)) { return; }
      const clickedButtonOrAnchor = target.closest('button, a'); const clickedEditable = clickedButtonOrAnchor || target.closest('p,h1,h2,h3,h4,h5,h6,span,div,img,li,td,th,strong,em,b,i');
      if (clickedEditable) { const isElementActuallyEditable = isEditableElement(clickedEditable); if (isElementActuallyEditable) { if (clickedEditable !== selectedElement) { clearElementSelection(); selectedElement = clickedEditable; selectedElement.dataset.vheElementSelected = 'true'; showElementToolbar(selectedElement); } else { showElementToolbar(selectedElement); } event.stopPropagation(); return; } }
      if (selectedElement) { clearElementSelection(); hideElementToolbar(); }
    }
    function handleIframeDoubleClick(event) { if (!iframeDoc || currentContentLoading || isPreviewMode) return; const target = event.target; if (selectedElement && isTextEditable(selectedElement) && (target === selectedElement || (target.nodeType === Node.TEXT_NODE && target.parentElement === selectedElement))) { makeEditable(selectedElement); event.preventDefault(); event.stopPropagation(); } }
    function handleIframeBlur(event) { if (!iframeWin || currentContentLoading || isPreviewMode) return; const target = event.target; if (target && target.ownerDocument === iframeDoc && target.isContentEditable) { setTimeout(() => { const activeElement = document.activeElement; if (!blockToolbar?.contains(activeElement) && !elementToolbar?.contains(activeElement)) { makeUneditable(target); } }, 50); } }
    function isEditableElement(element) { if (!element || typeof element.tagName !== 'string' || element === iframeDoc?.body || element === iframeDoc?.documentElement) return false; return ['P','H1','H2','H3','H4','H5','H6','BUTTON','A','IMG','DIV','SPAN','LI','UL','OL','HEADER','FOOTER','SECTION','ARTICLE','ASIDE','NAV','TD','TH','STRONG','EM','B','I','PRE','BLOCKQUOTE','FIGURE'].includes(element.tagName); }
    function isTextEditable(element) { if (!element || typeof element.tagName !== 'string') return false; const textLikeTags = [ 'P', 'H1', 'H2', 'H3', 'H4', 'H5', 'H6', 'SPAN', 'A', 'BUTTON', 'LI', 'TD', 'TH', 'CAPTION', 'STRONG', 'EM', 'B', 'I', 'U', 'S', 'MARK', 'SMALL', 'SUB', 'SUP', 'PRE', 'CODE', 'BLOCKQUOTE', 'Q', 'LABEL' ]; const nonTextTags = ['IMG', 'UL', 'OL', 'HR', 'BR', 'VIDEO', 'IFRAME', 'CANVAS', 'TABLE', 'THEAD', 'TBODY', 'TR', 'FORM', 'FIGURE', 'SVG', 'AUDIO']; return textLikeTags.includes(element.tagName) && !nonTextTags.includes(element.tagName); }
    function makeEditable(element) { if (!element || element.isContentEditable || !isTextEditable(element)) return; element.dataset.originalHtml = element.innerHTML; element.contentEditable = "true"; element.focus(); hideElementToolbar(); console.log("Made editable:", element); }
    function makeUneditable(element) { if (!element || !element.isContentEditable) return; element.contentEditable = "false"; const originalHtml = element.dataset.originalHtml; const newHtml = element.innerHTML; delete element.dataset.originalHtml; if (originalHtml !== newHtml) { console.log("Content changed:", element); addHistorySnapshot(`Edited text in ${element.tagName}`); } if (element === selectedElement) { element.dataset.vheElementSelected = 'true'; showElementToolbar(element); } }
    function clearElementHover() { if (hoveredElement) { try { delete hoveredElement.dataset.vheElementHover; } catch(e) {} hoveredElement = null; } }
    function clearBlockHover() { if (hoveredBlock) { try { delete hoveredBlock.dataset.vheBlockHover; } catch(e) {} } }
    function clearElementSelection() { if (selectedElement) { if (selectedElement.isContentEditable) makeUneditable(selectedElement); try { delete selectedElement.dataset.vheElementSelected; } catch(e) {} selectedElement = null; } }

    // --- Toolbars Management ---
    function removeTailwindPrefix(element, prefixOrRegex) { if (!element || !element.classList) return; const classesToRemove = []; element.classList.forEach(cls => { if ((typeof prefixOrRegex === 'string' && cls.startsWith(prefixOrRegex)) || (prefixOrRegex instanceof RegExp && prefixOrRegex.test(cls))) { classesToRemove.push(cls); } }); if (classesToRemove.length > 0) { element.classList.remove(...classesToRemove); } }
    function applyInlineStyle(element, property, value) {
        if (!element || !element.style) return;
        const styleMap = { color: TEXT_COLOR_CLASSES_REGEX, fontSize: /^text-(?:xs|sm|base|lg|xl|[2-9]xl)$/, fontWeight: /^font-(?:thin|extralight|light|normal|medium|semibold|bold|extrabold|black)$/, lineHeight: /^leading-(?:none|tight|snug|normal|relaxed|loose|\d+)$/, letterSpacing: /^tracking-(?:tighter|tight|normal|wide|wider|widest)$/, opacity: /^opacity-(?:0|[1-9]\d?|100)$/, textAlign: /^text-(?:left|center|right|justify|start|end)$/, backgroundColor: BG_COLOR_CLASSES_REGEX, };
        if (styleMap[property]) { removeTailwindPrefix(element, styleMap[property]); }
        if (property === 'backgroundColor') { removeTailwindPrefix(element, BG_GRADIENT_CLASSES_REGEX); element.style.backgroundImage = ''; }
        element.style[property] = value;
    }
    function applyTailwindClass(element, classesToAdd, competingClassesRegexOrArray) {
        if (!element || !element.classList) return;
        if (competingClassesRegexOrArray) { if (competingClassesRegexOrArray instanceof RegExp) { removeTailwindPrefix(element, competingClassesRegexOrArray); } else if (Array.isArray(competingClassesRegexOrArray)) { element.classList.remove(...competingClassesRegexOrArray); } }
        if (classesToAdd && classesToAdd.length > 0) {
            const classToAdd = classesToAdd[0];
            if (TEXT_COLOR_CLASSES_REGEX.test(classToAdd)) element.style.removeProperty('color');
            else if (BG_COLOR_CLASSES_REGEX.test(classToAdd)) { element.style.removeProperty('background-color'); element.style.removeProperty('background-image'); }
            else if (/^font-(?:thin|extralight|light|normal|medium|semibold|bold|extrabold|black)$/.test(classToAdd)) element.style.removeProperty('font-weight');
            else if (/^text-(?:left|center|right|justify|start|end)$/.test(classToAdd)) element.style.removeProperty('text-align');
            element.classList.add(...classesToAdd);
        }
    }
    function getElementStyleValue(element, property) {
        if (!element || !iframeWin) return ''; let value = ''; try { value = iframeWin.getComputedStyle(element)[property]; } catch(e) { console.warn("getComputedStyle failed:", e); return ''; }
        if (property === 'color' && value.startsWith('rgb')) { try { const rgb = value.match(/\d+/g).map(Number); value = '#' + rgb.map(x => { const hex = x.toString(16); return hex.length === 1 ? '0' + hex : hex; }).join(''); } catch (e) { value = '#000000'; } }
        else if (property === 'backgroundColor' && value.startsWith('rgb')) { try { const rgba = value.match(/[\d.]+/g).map(Number); if (rgba.length === 4 && rgba[3] === 0) { value = 'transparent'; } else { value = '#' + rgba.slice(0, 3).map(x => { const hex = Math.round(x).toString(16); return hex.length === 1 ? '0' + hex : hex; }).join(''); } } catch (e) { value = '#ffffff'; } }
        if (property === 'opacity' && element.style.opacity) { value = element.style.opacity; } if (property === 'fontSize' && element.style.fontSize) { value = element.style.fontSize; } if (property === 'lineHeight' && element.style.lineHeight) { value = element.style.lineHeight; } if (property === 'letterSpacing' && element.style.letterSpacing) { value = element.style.letterSpacing; } if (property === 'fontFamily' && element.style.fontFamily) { value = element.style.fontFamily; }
        return value || '';
    }
    function requestHideToolbar(delay = 250) { if (hideToolbarTimer) { clearTimeout(hideToolbarTimer); } hideToolbarTimer = setTimeout(() => { hideToolbarTimer = null; const currentlyOverBlock = hoveredBlock?.matches(':hover') ?? false; const currentlyOverToolbar = blockToolbar?.matches(':hover') ?? false; if (!currentlyOverBlock && !currentlyOverToolbar && !isColorPickerActive) { hideBlockToolbar(); if (hoveredBlock) { clearBlockHover(); hoveredBlock = null; } } }, delay); }
    function showBlockToolbar(blockElement) { if (!blockToolbar || !blockElement || !iframe || !iframeWin || blockElement === iframeDoc?.body || blockElement === iframeDoc?.documentElement || isPreviewMode) { hideBlockToolbar(); return; } if (hideToolbarTimer) { clearTimeout(hideToolbarTimer); hideToolbarTimer = null; } try { const bgColorPicker = document.getElementById('vhe-block-bg-color-picker'); if (bgColorPicker) { let currentBgColor = getElementStyleValue(blockElement, 'backgroundColor'); if (!currentBgColor || currentBgColor === 'rgba(0, 0, 0, 0)' || currentBgColor === 'transparent') { currentBgColor = '#ffffff'; } if (currentBgColor.startsWith('rgb')) { try { const rgb = currentBgColor.match(/\d+/g).map(Number); currentBgColor = '#' + rgb.slice(0, 3).map(x => { const hex = x.toString(16); return hex.length === 1 ? '0' + hex : hex; }).join(''); } catch (e) { currentBgColor = '#ffffff'; } } bgColorPicker.value = currentBgColor; } const blockRect = blockElement.getBoundingClientRect(); const iframeRect = iframe.getBoundingClientRect(); const isVisible = blockRect.bottom > 0 && blockRect.top < iframeWin.innerHeight && blockRect.right > 0 && blockRect.left < iframeWin.innerWidth; if (!isVisible) { hideBlockToolbar(); return; } let tbNeedsToggle = false; if (blockToolbar.style.display==='none'){blockToolbar.style.visibility='hidden';blockToolbar.style.display='flex';tbNeedsToggle=true;} const tbW = blockToolbar.offsetWidth; const tbH = blockToolbar.offsetHeight; if(tbNeedsToggle){blockToolbar.style.display='none';blockToolbar.style.visibility='visible';} if(tbW===0||tbH===0){console.warn("Block toolbar 0 dims.");hideBlockToolbar();return;} const scrollY = window.scrollY||window.pageYOffset; const scrollX=window.scrollX||window.pageXOffset; let top=iframeRect.top+scrollY+blockRect.top-tbH-TOOLBAR_OFFSET; let left=iframeRect.left+scrollX+blockRect.left+TOOLBAR_OFFSET; const minTop=iframeRect.top+scrollY+EDITOR_HEADER_HEIGHT+TOOLBAR_OFFSET; const maxTop=iframeRect.top+scrollY+iframeRect.height-tbH-TOOLBAR_OFFSET; const minLeft=iframeRect.left+scrollX+TOOLBAR_OFFSET; const maxLeft=iframeRect.left+scrollX+iframeRect.width-tbW-TOOLBAR_OFFSET; top=Math.max(minTop,Math.min(top,maxTop)); left=Math.max(minLeft,Math.min(left,maxLeft)); blockToolbar.style.top=`${Math.round(top)}px`; blockToolbar.style.left=`${Math.round(left)}px`; if(blockToolbar.style.display!=='flex'){blockToolbar.style.display='flex';} blockToolbar._targetBlock=blockElement; } catch(error){console.error("Error in showBlockToolbar:",error);hideBlockToolbar();} }
    function hideBlockToolbar() { if (blockToolbar && blockToolbar.style.display !== 'none') { blockToolbar.style.display = 'none'; delete blockToolbar._targetBlock; } isColorPickerActive = false; if (hideToolbarTimer) { clearTimeout(hideToolbarTimer); hideToolbarTimer = null; } }

    // --- UPDATED generateElementToolbarContent ---
    function generateElementToolbarContent(element) {
      if (!elementToolbarContent || !element) return;
      elementToolbarContent.innerHTML = ''; const tagName = element.tagName;
      let headerHtml = `<div class="vhe-toolbar-group flex justify-between items-center border-b-0 pb-1 mb-2"><span class="text-xs font-bold text-indigo-700 block">${tagName}</span><div class="flex gap-2 pr-8"><button data-action="clone-element" title="Clone Element" class="p-1 text-sm rounded hover:bg-indigo-100 text-indigo-600"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="8" y="8" width="12" height="12" rx="2" ry="2"></rect><path d="M16 8V6a2 2 0 0 0-2-2H6a2 2 0 0 0-2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><button data-action="delete-element" title="Delete Element" class="p-1 text-sm rounded hover:bg-red-100 text-red-500"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 6h18"></path><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6"></path><path d="M8 6V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path></svg></button></div></div>`;
      let specificHtml = '';

      // --- Generate Button/Anchor Toolbar ---
      if (tagName === 'BUTTON' || tagName === 'A') {
        if(tagName === 'A' && element.dataset.vheLinkWrapper === 'true' && element.querySelector('button')) { const innerButton = element.querySelector('button'); if (innerButton) { return generateElementToolbarContent(innerButton); } }
        specificHtml += `<div class="flex border-b border-gray-200 mb-3" id="vhe-tab-buttons"><button class="vhe-tab-button active" data-tab="text">Text</button><button class="vhe-tab-button" data-tab="style">Style</button><button class="vhe-tab-button" data-tab="link">Link</button></div>`;
        specificHtml += `<div id="vhe-tab-content">`; // Wrapper for tab panes
        specificHtml += `<div data-tab-content="text" class="">${generateTextControlsHtml(element)}</div>`;
        specificHtml += `<div data-tab-content="style" class="hidden">${generateButtonStyleControlsHtml(element)}</div>`;
        specificHtml += `<div data-tab-content="link" class="hidden">${generateButtonLinkControlsHtml(element)}</div>`;
        specificHtml += `</div>`; // Close #vhe-tab-content
      }
      // --- Generate Standard Text Toolbar (excluding A) ---
      else if (isTextEditable(element)) {
         specificHtml += `<div class="flex border-b border-gray-200 mb-3" id="vhe-tab-buttons"><button class="vhe-tab-button active" data-tab="text">Text</button><button class="vhe-tab-button" data-tab="appearance">Style</button><button class="vhe-tab-button" data-tab="hyperlink">Link</button></div>`;
         specificHtml += `<div id="vhe-tab-content">`; // Wrapper for tab panes
         specificHtml += `<div data-tab-content="text" class="">${generateTextControlsHtml(element)}</div>`;
         specificHtml += `<div data-tab-content="appearance" class="hidden">${generateAppearanceControlsHtml(element)}</div>`;
         specificHtml += `<div data-tab-content="hyperlink" class="hidden">${generateHyperlinkControlsHtml(element)}</div>`;
         specificHtml += `</div>`; // Close #vhe-tab-content
      }
      // --- Placeholder ---
      else { specificHtml += `<div class="text-xs text-gray-500 p-1">Container element (${tagName}). Style via children or blocks.</div>`; }

      elementToolbarContent.innerHTML = headerHtml + specificHtml;
      addElementToolbarListeners(element);
    }

    // --- Helper Functions to Generate Toolbar Sections ---
    function generateTextControlsHtml(element) {
        let html = ''; html += `<div class="grid grid-cols-2 gap-x-3 gap-y-2">`; // Grid
        const currentAlign = getElementStyleValue(element, 'textAlign'); html += `<div class="vhe-toolbar-group mb-1"><label class="text-xs mb-1">Alignment</label><div class="flex items-center gap-1">`; ['left', 'center', 'right', 'justify'].forEach(align => { const isCurrent = currentAlign === align || (align === 'left' && currentAlign === 'start') || (align === 'right' && currentAlign === 'end'); const iconSvg = { left: '<svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 10h10M4 14h16M4 18h10"></path></svg>', center: '<svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M7 10h10M4 14h16M7 18h10"></path></svg>', right: '<svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M10 10h10M4 14h16M10 18h10"></path></svg>', justify: '<svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 10h16M4 14h16M4 18h16"></path></svg>' }[align]; html += `<button data-align="${align}" title="Align ${align.charAt(0).toUpperCase() + align.slice(1)}" class="p-1 rounded hover:bg-gray-200 ${isCurrent ? 'bg-indigo-100 text-indigo-700 ring-1 ring-indigo-300' : 'text-gray-600'}">${iconSvg}</button>`; }); html += `</div></div>`;
        const currentSizePxStr = getElementStyleValue(element, 'fontSize'); const currentSizePx = parseInt(currentSizePxStr, 10) || 16; html += `<div class="vhe-toolbar-group mb-1"><label for="vhe-font-size" class="text-xs mb-1">Size</label><select id="vhe-font-size" class="w-full p-1 border rounded text-xs">`; const commonSizes = [10, 12, 14, 16, 18, 20, 24, 30, 36, 48, 60, 72, 96]; if (!commonSizes.includes(currentSizePx)) { commonSizes.push(currentSizePx); commonSizes.sort((a, b) => a - b); } commonSizes.forEach(size => { if (size <= 100) { html += `<option value="${size}" ${size === currentSizePx ? 'selected' : ''}>${size}px</option>`; } }); html += `</select></div>`;
        let currentFont = getElementStyleValue(element, 'fontFamily').split(',')[0].replace(/['"]/g, '').trim() || "Current"; if (FONT_FACES.indexOf(currentFont) === -1 && currentFont !== "Current") { currentFont = "Current"; } html += `<div class="vhe-toolbar-group mb-1"><label for="vhe-typeface" class="text-xs mb-1">Typeface</label><select id="vhe-typeface" class="w-full p-1 border rounded text-xs">`; FONT_FACES.forEach(font => { if (font === "Current") { const currentActualFont = getElementStyleValue(element, 'fontFamily').split(',')[0].replace(/['"]/g, '').trim() || 'Default'; html += `<option value="" ${currentFont === "Current" ? 'selected' : ''}>${currentActualFont} (Current)</option>`; } else { html += `<option value="${font}" ${currentFont === font ? 'selected' : ''}>${font}</option>`; } }); html += `</select></div>`;
        let currentWeight = 'Normal'; for (const [name, twClass] of Object.entries(FONT_WEIGHTS)) { if (element.classList.contains(twClass)) { currentWeight = name; break; } } html += `<div class="vhe-toolbar-group mb-1"><label for="vhe-font-weight" class="text-xs mb-1">Weight</label><select id="vhe-font-weight" class="w-full p-1 border rounded text-xs">`; Object.keys(FONT_WEIGHTS).forEach(name => { html += `<option value="${name}" ${name === currentWeight ? 'selected' : ''}>${name}</option>`; }); html += `</select></div>`; html += `</div>`; // Close grid
        let currentLineHeight = parseFloat(getElementStyleValue(element, 'lineHeight')); if (isNaN(currentLineHeight)) currentLineHeight = 1.5; const lineHeightSliderVal = Math.round(Math.max(0, Math.min(100, (currentLineHeight - 1) * 100))); let currentLetterSpacingEm = 0; const currentLetterSpacingStr = getElementStyleValue(element, 'letterSpacing'); if (currentLetterSpacingStr && currentLetterSpacingStr.endsWith('em')) { currentLetterSpacingEm = parseFloat(currentLetterSpacingStr) || 0; } else if (currentLetterSpacingStr === 'normal') { currentLetterSpacingEm = 0; } const letterSpacingSliderVal = Math.round(Math.max(0, Math.min(100, (currentLetterSpacingEm / 0.15) * 100))); html += `<div class="vhe-toolbar-group grid grid-cols-2 gap-3 mb-1 mt-1"><div><label for="vhe-line-height" class="block text-xs mb-1">Line height</label><input type="range" id="vhe-line-height" min="0" max="100" value="${lineHeightSliderVal}" class="w-full h-1.5 bg-gray-200 rounded cursor-pointer"></div><div><label for="vhe-letter-spacing" class="block text-xs mb-1">Letter spacing</label><input type="range" id="vhe-letter-spacing" min="0" max="100" value="${letterSpacingSliderVal}" class="w-full h-1.5 bg-gray-200 rounded cursor-pointer"></div></div>`; return html;
    }
    function generateAppearanceControlsHtml(element) { // For standard text
        let html = ''; const currentColor = getElementStyleValue(element, 'color') || '#000000';
        html += `<div class="vhe-toolbar-group mb-2"><label class="text-xs mb-1">Text Color</label><div class="flex items-center gap-2 mt-1"><div class="flex flex-wrap gap-1">`; PREDEFINED_COLORS.forEach(color => { const hasClass = element.classList.contains(color.class); const isCurrentInline = !hasClass && currentColor.toLowerCase() === color.value.toLowerCase(); const isActive = hasClass || isCurrentInline; html += `<button data-color-class="${color.class}" data-color-value="${color.value}" title="${color.name}" class="w-6 h-6 rounded-full border ${isActive ? 'ring-2 ring-offset-1 ring-indigo-400' : ''}" style="background-color: ${color.value};"></button>`; }); html += `</div><div class="color-picker-wrapper" title="Custom Text Color"><input type="color" id="vhe-color-picker" value="${currentColor}" class="block-color-picker"><div class="color-picker-icon"><svg xmlns="http://www.w3.org/2000/svg" width="10" height="10" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"><path d="M12 2v8"></path><path d="M12 22v-8"></path><path d="M2 12h8"></path><path d="M22 12h-8"></path></svg></div></div></div></div>`;
        const hasHoverStyle = element.style.getPropertyValue('--vhe-hover-color') !== ''; let currentHoverColor = '#000000'; if (hasHoverStyle) { currentHoverColor = element.style.getPropertyValue('--vhe-hover-color'); } const currentHoverDurationValue = parseFloat(element.style.getPropertyValue('--vhe-hover-duration') || DEFAULT_HOVER_DURATION) || 0.2; const isHoverActive = hasHoverStyle || Array.from(element.classList).some(cls => HOVER_TEXT_COLOR_CLASSES_REGEX.test(cls));
        html += `<div class="vhe-toolbar-group mb-2 flex items-center justify-between"><label for="vhe-hover-toggle" class="text-xs mb-0">Hover Text Color</label><button type="button" id="vhe-hover-toggle" class="relative inline-flex items-center h-5 w-9 flex-shrink-0 cursor-pointer rounded-full border-2 border-transparent transition-colors duration-200 ease-in-out focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2 ${isHoverActive ? 'bg-indigo-600' : 'bg-gray-200'}" role="switch" aria-checked="${isHoverActive}"><span class="sr-only">Enable hover effects</span><span aria-hidden="true" class="pointer-events-none inline-block h-4 w-4 transform rounded-full bg-white shadow ring-0 transition duration-200 ease-in-out ${isHoverActive ? 'translate-x-4' : 'translate-x-0'}"></span></button></div>`;
        html += `<div id="vhe-hover-controls" class="${isHoverActive ? '' : 'hidden'} vhe-toolbar-group mb-2 border-t border-gray-100 pt-2 mt-2 space-y-3">`;
         html += `<div><label class="text-xs mb-1">Hover Text Color</label><div class="flex items-center gap-2 mt-1"><div class="flex flex-wrap gap-1">`; PREDEFINED_COLORS.forEach(color => { const hoverClass = color.class.replace('text-', 'hover:text-'); const hasHoverColorClass = element.classList.contains(hoverClass); const isCurrentHoverInline = !hasHoverColorClass && hasHoverStyle && currentHoverColor.toLowerCase() === color.value.toLowerCase(); const isActiveHover = hasHoverColorClass || isCurrentHoverInline; html += `<button data-hover-color-class="${hoverClass}" data-hover-color-value="${color.value}" title="Hover: ${color.name}" class="w-6 h-6 rounded-full border ${isActiveHover ? 'ring-2 ring-offset-1 ring-indigo-400' : ''}" style="background-color: ${color.value};"></button>`; }); html += `</div><div class="color-picker-wrapper" title="Custom Hover Text Color"><input type="color" id="vhe-hover-color-picker" value="${currentHoverColor}" class="block-color-picker"><div class="color-picker-icon"><svg xmlns="http://www.w3.org/2000/svg" width="10" height="10" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"><path d="M12 2v8"></path><path d="M12 22v-8"></path><path d="M2 12h8"></path><path d="M22 12h-8"></path></svg></div></div></div></div>`;
         html += `<div><div class="flex justify-between items-center"><label for="vhe-hover-duration-slider" class="text-xs mb-1">Hover Transition (s)</label><span id="vhe-hover-duration-value" class="text-xs text-gray-500 font-medium">${currentHoverDurationValue.toFixed(2)}s</span></div><input type="range" id="vhe-hover-duration-slider" min="0" max="1" step="0.05" value="${currentHoverDurationValue}" class="w-full h-1.5 bg-gray-200 rounded cursor-pointer mt-1"></div>`;
        html += `</div>`;
        let currentOpacity = parseFloat(getElementStyleValue(element, 'opacity')); if (isNaN(currentOpacity)) currentOpacity = 1.0; const opacitySliderVal = Math.round(Math.max(0, Math.min(100, currentOpacity * 100))); html += `<div class="vhe-toolbar-group mb-1"><label for="vhe-opacity" class="block text-xs mb-1">Opacity</label><input type="range" id="vhe-opacity" min="0" max="100" value="${opacitySliderVal}" class="w-full h-1.5 bg-gray-200 rounded cursor-pointer"></div>`; return html;
    }
    function generateHyperlinkControlsHtml(element) { // For standard text
        let html = ''; let currentHref = element.tagName === 'A' ? (element.getAttribute('href') || '') : ''; const isLink = element.tagName === 'A'; html += `<div class="vhe-toolbar-group"><label for="vhe-link-href" class="text-xs mb-1">Link URL</label><div class="flex items-center gap-2 mt-1"><input type="text" id="vhe-link-href" placeholder="https://..." value="${currentHref}" class="flex-grow p-1 border rounded text-xs"><button id="vhe-link-apply" class="px-3 py-1.5 text-xs bg-indigo-100 text-indigo-700 rounded hover:bg-indigo-200">${isLink ? 'Update' : 'Apply'}</button>${isLink ? '<button id="vhe-link-remove" title="Remove Link" class="p-1 text-red-500 hover:bg-red-100 rounded"><svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg></button>' : ''}</div></div>`; return html;
    }
    // --- Helper for Button/Anchor Style Tab ---
    function generateButtonStyleControlsHtml(element) {
        let html = ''; const currentTextColor = getElementStyleValue(element, 'color') || '#000000'; const currentBgColor = getElementStyleValue(element, 'backgroundColor') || 'transparent';
        html += `<div class="vhe-toolbar-group mb-3"><label class="text-xs mb-1 font-medium text-gray-700">Text Color</label><div class="flex items-center gap-2 mt-1"><div class="flex flex-wrap gap-1">`; PREDEFINED_COLORS.forEach(color => { const hasClass = element.classList.contains(color.class); const isCurrentInline = !hasClass && currentTextColor.toLowerCase() === color.value.toLowerCase(); const isActive = hasClass || isCurrentInline; html += `<button data-color-class="${color.class}" data-color-value="${color.value}" title="${color.name}" class="w-6 h-6 rounded-full border ${isActive ? 'ring-2 ring-offset-1 ring-indigo-400' : ''}" style="background-color: ${color.value};"></button>`; }); html += `</div><div class="color-picker-wrapper" title="Custom Text Color"><input type="color" id="vhe-button-text-color-picker" value="${currentTextColor}" class="block-color-picker"><div class="color-picker-icon"><svg xmlns="http://www.w3.org/2000/svg" width="10" height="10" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"><path d="M12 2v8"></path><path d="M12 22v-8"></path><path d="M2 12h8"></path><path d="M22 12h-8"></path></svg></div></div></div></div>`;
        html += `<div class="vhe-toolbar-group mb-3"><label class="text-xs mb-1 font-medium text-gray-700">Background Color</label><div class="flex items-center gap-2 mt-1"><div class="flex flex-wrap gap-1">`; PREDEFINED_BG_COLORS.forEach(color => { const hasClass = element.classList.contains(color.class); const isCurrentInline = !hasClass && currentBgColor !== 'transparent' && currentBgColor.toLowerCase() === color.value.toLowerCase(); const isActiveTransparent = color.value === 'transparent' && (hasClass || currentBgColor === 'transparent'); const isActive = hasClass || isCurrentInline || isActiveTransparent; html += `<button data-bg-color-class="${color.class}" data-bg-color-value="${color.value}" title="${color.name}" class="w-6 h-6 rounded-full border ${isActive ? 'ring-2 ring-offset-1 ring-indigo-400' : 'border-gray-200'}" style="background-color: ${color.value};"></button>`; }); html += `</div><div class="color-picker-wrapper" title="Custom Background Color"><input type="color" id="vhe-button-bg-color-picker" value="${currentBgColor === 'transparent' ? '#ffffff' : currentBgColor}" class="block-color-picker"><div class="color-picker-icon"><svg xmlns="http://www.w3.org/2000/svg" width="10" height="10" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"><path d="M12 2v8"></path><path d="M12 22v-8"></path><path d="M2 12h8"></path><path d="M22 12h-8"></path></svg></div></div></div></div>`;
        const hasHoverTextColorStyle = element.style.getPropertyValue('--vhe-hover-text-color') !== ''; const hasHoverBgColorStyle = element.style.getPropertyValue('--vhe-hover-bg-color') !== ''; const hasHoverDurationStyle = element.style.getPropertyValue('--vhe-hover-duration') !== ''; const hasAnyHoverClass = Array.from(element.classList).some(cls => HOVER_TEXT_COLOR_CLASSES_REGEX.test(cls) || HOVER_BG_COLOR_CLASSES_REGEX.test(cls)); const isHoverActive = hasHoverTextColorStyle || hasHoverBgColorStyle || hasHoverDurationStyle || hasAnyHoverClass;
        let currentHoverTextColor = element.style.getPropertyValue('--vhe-hover-text-color') || '#ffffff'; let currentHoverBgColor = element.style.getPropertyValue('--vhe-hover-bg-color') || '#4F46E5'; const currentHoverDurationValue = parseFloat(element.style.getPropertyValue('--vhe-hover-duration') || DEFAULT_HOVER_DURATION) || 0.2;
        if (!hasHoverTextColorStyle && !hasHoverBgColorStyle) { /* Infer from classes if needed (simplified) */ }
        html += `<div class="vhe-toolbar-group mb-2 flex items-center justify-between pt-2 border-t border-gray-100"><label for="vhe-button-hover-toggle" class="text-xs font-medium text-gray-700 mb-0">Hover Effects</label><button type="button" id="vhe-button-hover-toggle" class="relative inline-flex items-center h-5 w-9 flex-shrink-0 cursor-pointer rounded-full border-2 border-transparent transition-colors duration-200 ease-in-out focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2 ${isHoverActive ? 'bg-indigo-600' : 'bg-gray-200'}" role="switch" aria-checked="${isHoverActive}"><span class="sr-only">Enable hover effects</span><span aria-hidden="true" class="pointer-events-none inline-block h-4 w-4 transform rounded-full bg-white shadow ring-0 transition duration-200 ease-in-out ${isHoverActive ? 'translate-x-4' : 'translate-x-0'}"></span></button></div>`;
        html += `<div id="vhe-button-hover-controls" class="${isHoverActive ? '' : 'hidden'} vhe-toolbar-group mb-2 space-y-3">`;
         html += `<div><label class="text-xs mb-1 text-gray-600">Hover Text Color</label><div class="flex items-center gap-2 mt-1"><div class="flex flex-wrap gap-1">`; PREDEFINED_COLORS.forEach(color => { const hoverClass = color.class.replace('text-', 'hover:text-'); const hasHoverColorClass = element.classList.contains(hoverClass); const isCurrentHoverInline = !hasHoverColorClass && hasHoverTextColorStyle && currentHoverTextColor.toLowerCase() === color.value.toLowerCase(); const isActiveHover = hasHoverColorClass || isCurrentHoverInline; html += `<button data-hover-text-color-value="${color.value}" title="Hover: ${color.name}" class="w-6 h-6 rounded-full border ${isActiveHover ? 'ring-2 ring-offset-1 ring-indigo-400' : ''}" style="background-color: ${color.value};"></button>`; }); html += `</div><div class="color-picker-wrapper" title="Custom Hover Text Color"><input type="color" id="vhe-button-hover-text-color-picker" value="${currentHoverTextColor}" class="block-color-picker"><div class="color-picker-icon"><svg xmlns="http://www.w3.org/2000/svg" width="10" height="10" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"><path d="M12 2v8"></path><path d="M12 22v-8"></path><path d="M2 12h8"></path><path d="M22 12h-8"></path></svg></div></div></div></div>`;
         html += `<div><label class="text-xs mb-1 text-gray-600">Hover Background Color</label><div class="flex items-center gap-2 mt-1"><div class="flex flex-wrap gap-1">`; PREDEFINED_BG_COLORS.forEach(color => { const hoverClass = color.class.replace('bg-', 'hover:bg-'); const hasHoverColorClass = element.classList.contains(hoverClass); const isCurrentHoverInline = !hasHoverColorClass && hasHoverBgColorStyle && currentHoverBgColor.toLowerCase() === color.value.toLowerCase(); const isActiveHover = hasHoverColorClass || isCurrentHoverInline; html += `<button data-hover-bg-color-value="${color.value}" title="Hover: ${color.name}" class="w-6 h-6 rounded-full border ${isActiveHover ? 'ring-2 ring-offset-1 ring-indigo-400' : 'border-gray-200'}" style="background-color: ${color.value};"></button>`; }); html += `</div><div class="color-picker-wrapper" title="Custom Hover Background Color"><input type="color" id="vhe-button-hover-bg-color-picker" value="${currentHoverBgColor === 'transparent' ? '#ffffff' : currentHoverBgColor}" class="block-color-picker"><div class="color-picker-icon"><svg xmlns="http://www.w3.org/2000/svg" width="10" height="10" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"><path d="M12 2v8"></path><path d="M12 22v-8"></path><path d="M2 12h8"></path><path d="M22 12h-8"></path></svg></div></div></div></div>`;
         html += `<div><div class="flex justify-between items-center"><label for="vhe-button-hover-duration-slider" class="text-xs mb-1 text-gray-600">Hover Transition (s)</label><span id="vhe-button-hover-duration-value" class="text-xs text-gray-500 font-medium">${currentHoverDurationValue.toFixed(2)}s</span></div><input type="range" id="vhe-button-hover-duration-slider" min="0" max="1" step="0.05" value="${currentHoverDurationValue}" class="w-full h-1.5 bg-gray-200 rounded cursor-pointer mt-1"></div>`;
        html += `</div>`; return html;
    }
    // --- Helper for Button/Anchor Link Tab ---
    function generateButtonLinkControlsHtml(element) {
        let html = ''; let currentHref = ''; let currentTarget = '_self'; let isLinked = false; const tagName = element.tagName;
        if (tagName === 'BUTTON') { const wrapperLink = element.closest('a[data-vhe-link-wrapper="true"]'); if (wrapperLink) { currentHref = wrapperLink.getAttribute('href') || ''; currentTarget = wrapperLink.getAttribute('target') || '_self'; isLinked = true; } }
        else if (tagName === 'A') { currentHref = element.getAttribute('href') || ''; currentTarget = element.getAttribute('target') || '_self'; isLinked = !!currentHref; }
        html += `<div class="vhe-toolbar-group space-y-3">`;
        html += `<div><label for="vhe-button-link-href" class="text-xs mb-1 font-medium text-gray-700">Link URL</label><input type="text" id="vhe-button-link-href" placeholder="https://..." value="${currentHref}" class="w-full p-1.5 border rounded text-xs mt-1 focus:ring-1 focus:ring-indigo-400 focus:border-indigo-400"></div>`;
        html += `<div><label for="vhe-button-link-target" class="text-xs mb-1 font-medium text-gray-700">Target</label><select id="vhe-button-link-target" class="w-full p-1.5 border rounded text-xs mt-1 focus:ring-1 focus:ring-indigo-400 focus:border-indigo-400"><option value="_self" ${currentTarget === '_self' ? 'selected' : ''}>Same Browser Tab</option><option value="_blank" ${currentTarget === '_blank' ? 'selected' : ''}>New Browser Tab</option></select></div>`;
        html += `<div class="flex items-center gap-2 pt-2"><button id="vhe-button-link-apply" class="flex-grow px-3 py-1.5 text-xs bg-indigo-600 text-white rounded hover:bg-indigo-700 font-medium">${isLinked ? 'Update Link' : 'Apply Link'}</button>`; if (isLinked) { html += `<button id="vhe-button-link-remove" title="Remove Link" class="p-1.5 text-red-500 hover:bg-red-100 rounded"><svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg></button>`; } html += `</div>`;
        html += `</div>`; return html;
    }

    // --- UPDATED showElementToolbar (removed dynamic height calc) ---
    function showElementToolbar(element) {
      if (!elementToolbar || !element || !iframe || !iframeWin || element.isContentEditable || isPreviewMode) { hideElementToolbar(); return; }
      try {
        generateElementToolbarContent(element);
        let tbNeedsToggle = false; if (elementToolbar.style.display === 'none') { elementToolbar.style.visibility = 'hidden'; elementToolbar.style.display = 'block'; tbNeedsToggle = true; }
        const elemRect = element.getBoundingClientRect(); const iframeRect = iframe.getBoundingClientRect(); const isVisible = elemRect.bottom > 0 && elemRect.top < iframeWin.innerHeight && elemRect.right > 0 && elemRect.left < iframeWin.innerWidth;
        if (!isVisible) { if (tbNeedsToggle) { elementToolbar.style.display = 'none'; elementToolbar.style.visibility = 'visible'; } hideElementToolbar(); return; }
        const scrollY = window.scrollY || window.pageYOffset; const scrollX = window.scrollX || window.pageXOffset;
        const tbH = elementToolbar.offsetHeight; const tbW = elementToolbar.offsetWidth; const spacing = TOOLBAR_OFFSET + 4;
        if (tbNeedsToggle) { elementToolbar.style.display = 'none'; elementToolbar.style.visibility = 'visible'; }
        if (tbH === 0 || tbW === 0) { console.warn("Elem toolbar 0 dims."); hideElementToolbar(); return; }
        // Position Calculation
        let top = iframeRect.top + scrollY + elemRect.top - tbH - spacing; let left = iframeRect.left + scrollX + elemRect.left; const minTopPos = iframeRect.top + scrollY + EDITOR_HEADER_HEIGHT + spacing; if (top < minTopPos) { top = iframeRect.top + scrollY + elemRect.bottom + spacing; } const maxLeft = iframeRect.left + scrollX + iframeRect.width - tbW - spacing; if (left > maxLeft) { left = maxLeft; } const minLeft = iframeRect.left + scrollX + spacing; left = Math.max(minLeft, left); const maxTop = iframeRect.top + scrollY + iframeRect.height - tbH - spacing; top = Math.min(top, maxTop); top = Math.max(minTopPos, top);
        elementToolbar.style.top = `${Math.round(top)}px`; elementToolbar.style.left = `${Math.round(left)}px`;
        if (elementToolbar.style.display !== 'block') { elementToolbar.style.display = 'block'; }
        updateElementToolbarOnScroll(element);
      } catch (error) { console.error("Err positioning elem toolbar:", error); hideElementToolbar(); }
    }
    function hideElementToolbar() { if (elementToolbar && elementToolbar.style.display !== 'none') { elementToolbar.style.display = 'none'; if(elementToolbarContent) elementToolbarContent.innerHTML = ''; } if (elementScrollListener && iframeWin) { iframeWin.removeEventListener('scroll', elementScrollListener); elementScrollListener = null; } }
    function updateElementToolbarOnScroll(element) { if (elementScrollListener && iframeWin) { iframeWin.removeEventListener('scroll', elementScrollListener); elementScrollListener = null; } if (elementToolbar?.style.display === 'block' && selectedElement === element) { elementScrollListener = () => { if (elementToolbar?.style.display === 'block' && selectedElement === element) { showElementToolbar(element); } else if (iframeWin && elementScrollListener) { iframeWin.removeEventListener('scroll', elementScrollListener); elementScrollListener = null; } }; if (iframeWin) { iframeWin.addEventListener('scroll', elementScrollListener, { passive: true }); } } }

    // --- UPDATED addElementToolbarListeners ---
    function addElementToolbarListeners(element) {
        if (!elementToolbarContent || !element) return;
        const tagName = element.tagName;
        // Common Listeners
        const cloneBtn = elementToolbarContent.querySelector('button[data-action="clone-element"]'); if (cloneBtn) { cloneBtn.addEventListener('click', () => cloneSelectedElement(element)); }
        const deleteBtn = elementToolbarContent.querySelector('button[data-action="delete-element"]'); if (deleteBtn) { deleteBtn.addEventListener('click', () => deleteSelectedElement(element)); }
        // Tab Switching
        const tabButtonsContainer = elementToolbarContent.querySelector('#vhe-tab-buttons');
        if (tabButtonsContainer) { const tabContentsContainer = elementToolbarContent.querySelector('#vhe-tab-content'); if (tabContentsContainer) { tabButtonsContainer.addEventListener('click', (e) => { const button = e.target.closest('.vhe-tab-button'); if (!button || button.classList.contains('active')) return; const tabName = button.dataset.tab; tabButtonsContainer.querySelectorAll('.vhe-tab-button').forEach(btn => btn.classList.remove('active')); button.classList.add('active'); tabContentsContainer.querySelectorAll('[data-tab-content]').forEach(content => { content.classList.toggle('hidden', content.dataset.tabContent !== tabName); }); }); } }
        // Common Text Controls
        addTextControlListeners(element);
        // Specific Listeners for Button OR Anchor
        if (tagName === 'BUTTON' || tagName === 'A') {
            addButtonStylingListeners(element);
            addButtonLinkListeners(element);
        }
        // Specific Listeners for OTHER Text Elements
        else if (isTextEditable(element)) {
             addStandardAppearanceListeners(element);
             addStandardHyperlinkListeners(element);
        }
    }

    // --- Helper to Add Text Control Listeners ---
    function addTextControlListeners(element) {
        elementToolbarContent.querySelectorAll('button[data-align]')?.forEach(btn => { btn.addEventListener('click', () => { const align = btn.dataset.align; const newClass = `text-${align}`; applyTailwindClass(element, [newClass], TEXT_ALIGN_CLASSES); addHistorySnapshot(`Align ${align}`); elementToolbarContent.querySelectorAll('button[data-align]').forEach(b => b.classList.remove('bg-indigo-100','text-indigo-700','ring-1','ring-indigo-300')); btn.classList.add('bg-indigo-100','text-indigo-700','ring-1','ring-indigo-300'); }); });
        const fontSizeSelect = document.getElementById('vhe-font-size'); if (fontSizeSelect) { fontSizeSelect.addEventListener('change', (e) => { const newSize = e.target.value; if (newSize) { applyInlineStyle(element, 'fontSize', `${newSize}px`); addHistorySnapshot(`Set font size ${newSize}px`); } }); }
        const typefaceSelect = document.getElementById('vhe-typeface'); if (typefaceSelect) { typefaceSelect.addEventListener('change', (e) => { const newFont = e.target.value; if (newFont) { const fontFamilyValue = `'${newFont}', sans-serif`; applyInlineStyle(element, 'fontFamily', fontFamilyValue); addHistorySnapshot(`Set font ${newFont}`); } else { element.style.removeProperty('font-family'); addHistorySnapshot(`Reset font`); } }); }
        const fontWeightSelect = document.getElementById('vhe-font-weight'); if (fontWeightSelect) { fontWeightSelect.addEventListener('change', (e) => { const weightName = e.target.value; const weightClass = FONT_WEIGHTS[weightName]; if (weightClass) { applyTailwindClass(element, [weightClass], FONT_WEIGHT_CLASSES); addHistorySnapshot(`Set weight ${weightName}`); } }); }
        const lineHeightSlider = document.getElementById('vhe-line-height'); if (lineHeightSlider) { lineHeightSlider.addEventListener('input', (e) => { const sliderValue = parseInt(e.target.value, 10); const lineHeight = 1 + (sliderValue / 100); applyInlineStyle(element, 'lineHeight', lineHeight.toFixed(2)); }); lineHeightSlider.addEventListener('change', () => { addHistorySnapshot(`Adjust line height`); }); }
        const letterSpacingSlider = document.getElementById('vhe-letter-spacing'); if (letterSpacingSlider) { letterSpacingSlider.addEventListener('input', (e) => { const sliderValue = parseInt(e.target.value, 10); const letterSpacing = (sliderValue / 100) * 0.15; applyInlineStyle(element, 'letterSpacing', `${letterSpacing.toFixed(3)}em`); }); letterSpacingSlider.addEventListener('change', () => { addHistorySnapshot(`Adjust letter spacing`); }); }
    }
    // --- Helper for Button/Anchor Style Listeners ---
    function addButtonStylingListeners(element) {
        // Text Color
        elementToolbarContent.querySelectorAll('button[data-color-class]')?.forEach(btn => { btn.addEventListener('click', () => { const colorClass = btn.dataset.colorClass; const colorValue = btn.dataset.colorValue; applyTailwindClass(element, [colorClass], TEXT_COLOR_CLASSES_REGEX); addHistorySnapshot(`Set ${element.tagName} text color ${colorClass}`); const picker = document.getElementById('vhe-button-text-color-picker'); if(picker) picker.value = colorValue; elementToolbarContent.querySelectorAll('button[data-color-class]').forEach(b => b.classList.remove('ring-2','ring-offset-1','ring-indigo-400')); btn.classList.add('ring-2','ring-offset-1','ring-indigo-400'); }); });
        const textColorPicker = document.getElementById('vhe-button-text-color-picker'); if (textColorPicker) { textColorPicker.addEventListener('input', (e) => { const newColor = e.target.value; applyInlineStyle(element, 'color', newColor); elementToolbarContent.querySelectorAll('button[data-color-class]').forEach(b => { const isActive = b.dataset.colorValue.toLowerCase() === newColor.toLowerCase(); b.classList.toggle('ring-2', isActive); b.classList.toggle('ring-offset-1', isActive); b.classList.toggle('ring-indigo-400', isActive); }); }); textColorPicker.addEventListener('change', (e) => { addHistorySnapshot(`Set ${element.tagName} custom text color ${e.target.value}`); }); }
        // Background Color
        elementToolbarContent.querySelectorAll('button[data-bg-color-class]')?.forEach(btn => { btn.addEventListener('click', () => { const bgClass = btn.dataset.bgColorClass; const bgColorValue = btn.dataset.bgColorValue; if (bgClass === 'bg-transparent') { applyInlineStyle(element, 'backgroundColor', 'transparent'); } else { applyTailwindClass(element, [bgClass], BG_COLOR_CLASSES_REGEX); applyTailwindClass(element, null, BG_GRADIENT_CLASSES_REGEX); } addHistorySnapshot(`Set ${element.tagName} background ${bgClass}`); const picker = document.getElementById('vhe-button-bg-color-picker'); if(picker) picker.value = bgColorValue === 'transparent' ? '#ffffff' : bgColorValue; elementToolbarContent.querySelectorAll('button[data-bg-color-class]').forEach(b => b.classList.remove('ring-2','ring-offset-1','ring-indigo-400')); btn.classList.add('ring-2','ring-offset-1','ring-indigo-400'); }); });
        const bgColorPicker = document.getElementById('vhe-button-bg-color-picker'); if (bgColorPicker) { bgColorPicker.addEventListener('input', (e) => { const newColor = e.target.value; applyInlineStyle(element, 'backgroundColor', newColor); elementToolbarContent.querySelectorAll('button[data-bg-color-class]').forEach(b => { const isActive = b.dataset.bgColorValue.toLowerCase() === newColor.toLowerCase(); b.classList.toggle('ring-2', isActive); b.classList.toggle('ring-offset-1', isActive); b.classList.toggle('ring-indigo-400', isActive); }); }); bgColorPicker.addEventListener('change', (e) => { addHistorySnapshot(`Set ${element.tagName} custom background ${e.target.value}`); }); }
        // Hover Effects Toggle
        const hoverToggle = document.getElementById('vhe-button-hover-toggle'); const hoverControls = document.getElementById('vhe-button-hover-controls');
        if (hoverToggle && hoverControls) {
          hoverToggle.addEventListener('click', () => {
            const isEnabled = hoverToggle.getAttribute('aria-checked') === 'true'; const newState = !isEnabled; hoverToggle.setAttribute('aria-checked', newState); hoverToggle.classList.toggle('bg-indigo-600', newState); hoverToggle.classList.toggle('bg-gray-200', !newState); hoverToggle.querySelector('span[aria-hidden="true"]').classList.toggle('translate-x-4', newState); hoverToggle.querySelector('span[aria-hidden="true"]').classList.toggle('translate-x-0', !newState); hoverControls.classList.toggle('hidden', !newState);
            if (!newState) { removeTailwindPrefix(element, HOVER_TEXT_COLOR_CLASSES_REGEX); removeTailwindPrefix(element, HOVER_BG_COLOR_CLASSES_REGEX); updateHoverStyleTag(element, null, null, null); addHistorySnapshot(`Disable ${element.tagName} hover effects`); }
            else { let currentHoverText = element.style.getPropertyValue('--vhe-hover-text-color'); let currentHoverBg = element.style.getPropertyValue('--vhe-hover-bg-color'); let currentDuration = element.style.getPropertyValue('--vhe-hover-duration') || DEFAULT_HOVER_DURATION; if(!currentHoverText && !currentHoverBg) { currentHoverText = '#FFFFFF'; currentHoverBg = '#4338CA'; } removeTailwindPrefix(element, HOVER_TEXT_COLOR_CLASSES_REGEX); removeTailwindPrefix(element, HOVER_BG_COLOR_CLASSES_REGEX); updateHoverStyleTag(element, currentHoverText, currentHoverBg, currentDuration); /* Update UI controls */ addHistorySnapshot(`Enable ${element.tagName} hover effects`); }
          });
        }
        // Hover Text Color Swatches/Picker
        elementToolbarContent.querySelectorAll('button[data-hover-text-color-value]')?.forEach(btn => { btn.addEventListener('click', () => { const hoverColorValue = btn.dataset.hoverTextColorValue; const currentHoverBg = element.style.getPropertyValue('--vhe-hover-bg-color'); const currentDuration = element.style.getPropertyValue('--vhe-hover-duration') || DEFAULT_HOVER_DURATION; removeTailwindPrefix(element, HOVER_TEXT_COLOR_CLASSES_REGEX); updateHoverStyleTag(element, hoverColorValue, currentHoverBg, currentDuration); addHistorySnapshot(`Set ${element.tagName} hover text color ${hoverColorValue}`); const picker = document.getElementById('vhe-button-hover-text-color-picker'); if(picker) picker.value = hoverColorValue; elementToolbarContent.querySelectorAll('button[data-hover-text-color-value]').forEach(b => b.classList.remove('ring-2','ring-offset-1','ring-indigo-400')); btn.classList.add('ring-2','ring-offset-1','ring-indigo-400'); }); });
        const hoverTextColorPicker = document.getElementById('vhe-button-hover-text-color-picker'); if (hoverTextColorPicker) { hoverTextColorPicker.addEventListener('input', (e) => { const newHoverColor = e.target.value; const currentHoverBg = element.style.getPropertyValue('--vhe-hover-bg-color'); const currentDuration = element.style.getPropertyValue('--vhe-hover-duration') || DEFAULT_HOVER_DURATION; removeTailwindPrefix(element, HOVER_TEXT_COLOR_CLASSES_REGEX); updateHoverStyleTag(element, newHoverColor, currentHoverBg, currentDuration); elementToolbarContent.querySelectorAll('button[data-hover-text-color-value]').forEach(b => { /* Update swatch state */ }); }); hoverTextColorPicker.addEventListener('change', (e) => { addHistorySnapshot(`Set custom ${element.tagName} hover text color ${e.target.value}`); }); }
        // Hover Background Color Swatches/Picker
        elementToolbarContent.querySelectorAll('button[data-hover-bg-color-value]')?.forEach(btn => { btn.addEventListener('click', () => { const hoverColorValue = btn.dataset.hoverBgColorValue; const currentHoverText = element.style.getPropertyValue('--vhe-hover-text-color'); const currentDuration = element.style.getPropertyValue('--vhe-hover-duration') || DEFAULT_HOVER_DURATION; removeTailwindPrefix(element, HOVER_BG_COLOR_CLASSES_REGEX); updateHoverStyleTag(element, currentHoverText, hoverColorValue, currentDuration); addHistorySnapshot(`Set ${element.tagName} hover background ${hoverColorValue}`); const picker = document.getElementById('vhe-button-hover-bg-color-picker'); if(picker) picker.value = hoverColorValue === 'transparent' ? '#ffffff' : hoverColorValue; elementToolbarContent.querySelectorAll('button[data-hover-bg-color-value]').forEach(b => b.classList.remove('ring-2','ring-offset-1','ring-indigo-400')); btn.classList.add('ring-2','ring-offset-1','ring-indigo-400'); }); });
        const hoverBgColorPicker = document.getElementById('vhe-button-hover-bg-color-picker'); if (hoverBgColorPicker) { hoverBgColorPicker.addEventListener('input', (e) => { const newHoverColor = e.target.value; const currentHoverText = element.style.getPropertyValue('--vhe-hover-text-color'); const currentDuration = element.style.getPropertyValue('--vhe-hover-duration') || DEFAULT_HOVER_DURATION; removeTailwindPrefix(element, HOVER_BG_COLOR_CLASSES_REGEX); updateHoverStyleTag(element, currentHoverText, newHoverColor, currentDuration); elementToolbarContent.querySelectorAll('button[data-hover-bg-color-value]').forEach(b => { /* Update swatch state */ }); }); hoverBgColorPicker.addEventListener('change', (e) => { addHistorySnapshot(`Set custom ${element.tagName} hover background ${e.target.value}`); }); }
        // Hover Duration Slider
        const hoverDurationSlider = document.getElementById('vhe-button-hover-duration-slider'); const hoverDurationValueDisplay = document.getElementById('vhe-button-hover-duration-value'); if (hoverDurationSlider && hoverDurationValueDisplay) { hoverDurationSlider.addEventListener('input', (e) => { const durationValue = parseFloat(e.target.value).toFixed(2); const durationString = `${durationValue}s`; const currentHoverText = element.style.getPropertyValue('--vhe-hover-text-color'); const currentHoverBg = element.style.getPropertyValue('--vhe-hover-bg-color'); updateHoverStyleTag(element, currentHoverText, currentHoverBg, durationString); hoverDurationValueDisplay.textContent = durationString; }); hoverDurationSlider.addEventListener('change', (e) => { const durationValue = parseFloat(e.target.value).toFixed(2); addHistorySnapshot(`Adjust ${element.tagName} hover transition to ${durationValue}s`); }); }
    }
    // --- UPDATED Helper for Button/Anchor Link Listeners ---
    function addButtonLinkListeners(element) {
        const linkHrefInput = document.getElementById('vhe-button-link-href'); const linkTargetSelect = document.getElementById('vhe-button-link-target'); const linkApplyBtn = document.getElementById('vhe-button-link-apply'); const linkRemoveBtn = document.getElementById('vhe-button-link-remove'); const tagName = element.tagName;
        if (linkApplyBtn && linkHrefInput && linkTargetSelect) {
            linkApplyBtn.addEventListener('click', () => {
                let url = linkHrefInput.value.trim(); const target = linkTargetSelect.value; if (url && !url.startsWith('http://') && !url.startsWith('https://') && !url.startsWith('#') && !url.startsWith('/')) { url = 'https://' + url; }
                if (tagName === 'BUTTON') {
                    const currentWrapper = element.closest('a[data-vhe-link-wrapper="true"]');
                    if (url) { if (currentWrapper) { currentWrapper.setAttribute('href', url); currentWrapper.setAttribute('target', target); addHistorySnapshot(`Updated button link to ${url}`); } else { const wrapper = iframeDoc.createElement('a'); wrapper.setAttribute('href', url); wrapper.setAttribute('target', target); wrapper.dataset.vheLinkWrapper = 'true'; wrapper.addEventListener('click', e => e.preventDefault()); wrapElement(element, wrapper); addHistorySnapshot(`Linked button to ${url}`); } showElementToolbar(element); }
                    else { if (currentWrapper) { unwrapElement(element, currentWrapper); addHistorySnapshot('Removed button link'); showElementToolbar(element); } }
                } else if (tagName === 'A') {
                    if (url) { const oldUrl = element.getAttribute('href'); element.setAttribute('href', url); element.setAttribute('target', target); if (!element.vheClickListenerAttached) { element.addEventListener('click', e => e.preventDefault()); element.vheClickListenerAttached = true; } addHistorySnapshot(oldUrl ? `Updated link to ${url}` : `Applied link ${url}`); showElementToolbar(element); }
                    else { if (element.hasAttribute('href')) { element.removeAttribute('href'); element.removeAttribute('target'); addHistorySnapshot('Removed link href'); showElementToolbar(element); } }
                }
            });
        }
        if (linkRemoveBtn) {
            linkRemoveBtn.addEventListener('click', () => {
                 if (tagName === 'BUTTON') { const currentWrapper = element.closest('a[data-vhe-link-wrapper="true"]'); if (currentWrapper) { unwrapElement(element, currentWrapper); addHistorySnapshot('Removed button link'); showElementToolbar(element); } }
                 else if (tagName === 'A') { if (element.hasAttribute('href')) { element.removeAttribute('href'); element.removeAttribute('target'); addHistorySnapshot('Removed link href'); showElementToolbar(element); } }
            });
        }
    }
    // --- Helper for Standard Appearance Listeners ---
    function addStandardAppearanceListeners(element) { // For non-button/anchor text elements
        elementToolbarContent.querySelectorAll('button[data-color-class]')?.forEach(btn => { btn.addEventListener('click', () => { const colorClass = btn.dataset.colorClass; const colorValue = btn.dataset.colorValue; applyTailwindClass(element, [colorClass], TEXT_COLOR_CLASSES_REGEX); addHistorySnapshot(`Set color ${colorClass}`); const picker = document.getElementById('vhe-color-picker'); if(picker) picker.value = colorValue; elementToolbarContent.querySelectorAll('button[data-color-class]').forEach(b => b.classList.remove('ring-2','ring-offset-1','ring-indigo-400')); btn.classList.add('ring-2','ring-offset-1','ring-indigo-400'); }); });
        const colorPicker = document.getElementById('vhe-color-picker'); if (colorPicker) { colorPicker.addEventListener('input', (e) => { const newColor = e.target.value; applyInlineStyle(element, 'color', newColor); elementToolbarContent.querySelectorAll('button[data-color-class]').forEach(b => { /* Update swatch state */ }); }); colorPicker.addEventListener('change', (e) => { addHistorySnapshot(`Set custom color ${e.target.value}`); }); }
        const hoverToggle = document.getElementById('vhe-hover-toggle'); const hoverControls = document.getElementById('vhe-hover-controls');
        if (hoverToggle && hoverControls) { hoverToggle.addEventListener('click', () => { const isEnabled = hoverToggle.getAttribute('aria-checked') === 'true'; const newState = !isEnabled; hoverToggle.setAttribute('aria-checked', newState); hoverToggle.classList.toggle('bg-indigo-600', newState); hoverToggle.classList.toggle('bg-gray-200', !newState); hoverToggle.querySelector('span[aria-hidden="true"]').classList.toggle('translate-x-4', newState); hoverToggle.querySelector('span[aria-hidden="true"]').classList.toggle('translate-x-0', !newState); hoverControls.classList.toggle('hidden', !newState); if (!newState) { removeTailwindPrefix(element, HOVER_TEXT_COLOR_CLASSES_REGEX); updateHoverStyleTag(element, null, null, null); addHistorySnapshot('Disable hover text color'); } else { let appliedColor = element.style.getPropertyValue('--vhe-hover-color'); let appliedDuration = element.style.getPropertyValue('--vhe-hover-duration') || DEFAULT_HOVER_DURATION; if (!appliedColor) appliedColor = PREDEFINED_COLORS.length > 0 ? PREDEFINED_COLORS[0].value : '#000000'; removeTailwindPrefix(element, HOVER_TEXT_COLOR_CLASSES_REGEX); updateHoverStyleTag(element, appliedColor, null, appliedDuration); /* Update UI */ addHistorySnapshot('Enable hover text color'); } }); }
        elementToolbarContent.querySelectorAll('button[data-hover-color-class]')?.forEach(btn => { btn.addEventListener('click', () => { const hoverColorValue = btn.dataset.hoverColorValue; const currentDuration = element.style.getPropertyValue('--vhe-hover-duration') || DEFAULT_HOVER_DURATION; removeTailwindPrefix(element, HOVER_TEXT_COLOR_CLASSES_REGEX); updateHoverStyleTag(element, hoverColorValue, null, currentDuration); /* Update UI */ addHistorySnapshot(`Set hover text color ${hoverColorValue}`); }); });
        const hoverColorPicker = document.getElementById('vhe-hover-color-picker'); if(hoverColorPicker) { hoverColorPicker.addEventListener('input', (e) => { const newHoverColor = e.target.value; const currentDuration = element.style.getPropertyValue('--vhe-hover-duration') || DEFAULT_HOVER_DURATION; removeTailwindPrefix(element, HOVER_TEXT_COLOR_CLASSES_REGEX); updateHoverStyleTag(element, newHoverColor, null, currentDuration); /* Update UI */ }); hoverColorPicker.addEventListener('change', e => addHistorySnapshot(`Set custom hover text color ${e.target.value}`)); }
        const hoverDurationSlider = document.getElementById('vhe-hover-duration-slider'); if(hoverDurationSlider) { hoverDurationSlider.addEventListener('input', (e) => { const durationValue = parseFloat(e.target.value).toFixed(2); const durationString = `${durationValue}s`; const currentColor = element.style.getPropertyValue('--vhe-hover-color'); updateHoverStyleTag(element, currentColor, null, durationString); document.getElementById('vhe-hover-duration-value').textContent = durationString; }); hoverDurationSlider.addEventListener('change', e => addHistorySnapshot(`Adjust hover transition to ${parseFloat(e.target.value).toFixed(2)}s`)); }
        const opacitySlider = document.getElementById('vhe-opacity'); if (opacitySlider) { opacitySlider.addEventListener('input', (e) => { const sliderValue = parseInt(e.target.value, 10); const opacity = sliderValue / 100; applyInlineStyle(element, 'opacity', opacity.toFixed(2)); }); opacitySlider.addEventListener('change', () => { addHistorySnapshot(`Adjust opacity`); }); }
     }
     // --- Helper for Standard Hyperlink Listeners ---
     function addStandardHyperlinkListeners(element) { // For non-button/anchor text
        const linkHrefInput = document.getElementById('vhe-link-href'); const linkApplyBtn = document.getElementById('vhe-link-apply'); const linkRemoveBtn = document.getElementById('vhe-link-remove');
        if (linkApplyBtn && linkHrefInput) {
            linkApplyBtn.addEventListener('click', () => {
                let url = linkHrefInput.value.trim(); if (url && !url.startsWith('http://') && !url.startsWith('https://') && !url.startsWith('#') && !url.startsWith('/')) { url = 'https://' + url; }
                if (!url) { if (element.tagName === 'A') { const contentNodes = Array.from(element.childNodes); const parent = element.parentNode; unwrapElement(contentNodes, element); addHistorySnapshot('Removed link'); if(parent && isEditableElement(parent)) showElementToolbar(parent); else hideElementToolbar(); } return; }
                if (element.tagName === 'A') { element.setAttribute('href', url); addHistorySnapshot(`Updated link to ${url}`); showElementToolbar(element); }
                else { const link = iframeDoc.createElement('a'); link.setAttribute('href', url); link.setAttribute('target', '_blank'); link.addEventListener('click', e => e.preventDefault()); wrapElement(element, link); addHistorySnapshot(`Wrapped in link to ${url}`); showElementToolbar(link); }
            });
        }
        if (linkRemoveBtn && element.tagName === 'A') {
            linkRemoveBtn.addEventListener('click', () => {
                const contentNodes = Array.from(element.childNodes); const parent = element.parentNode; unwrapElement(contentNodes, element); addHistorySnapshot('Removed link'); if(parent && isEditableElement(parent)) { showElementToolbar(parent); } else { hideElementToolbar();}
            });
        }
     }

     // --- Utility functions for wrapping/unwrapping ---
     function wrapElement(elementToWrap, wrapperElement) { if (!elementToWrap || !wrapperElement || !elementToWrap.parentNode) return; elementToWrap.parentNode.insertBefore(wrapperElement, elementToWrap); wrapperElement.appendChild(elementToWrap); }
     function unwrapElement(contentToKeep, wrapperElement) { if (!wrapperElement || !wrapperElement.parentNode) return; const parent = wrapperElement.parentNode; const content = contentToKeep instanceof NodeList ? Array.from(contentToKeep) : (contentToKeep ? [contentToKeep] : []); content.forEach(node => { parent.insertBefore(node, wrapperElement); }); wrapperElement.remove(); }

    // --- Block Actions, History, Save ---
    function cloneSelectedElement(element) {
      if (!element || (!element.parentNode && element !== iframeDoc?.body)) { console.warn("Cannot clone: Invalid element/parent."); return null; }
      try {
        element.classList.add('vhe-element-duplicating'); const clone = element.cloneNode(true);
        delete clone.dataset.vheElementSelected; delete clone.dataset.vheElementHover; delete clone.dataset.vheBlockId; delete clone.dataset.vheBlockHover; clone.removeAttribute('contenteditable'); delete clone.vheClickListenerAttached;
        clone.querySelectorAll('[data-vhe-element-selected], [data-vhe-element-hover]').forEach(child => { delete child.dataset.vheElementSelected; delete child.dataset.vheElementHover; });
        clone.classList.add('vhe-element-duplicating');
        setTimeout(() => {
          element.parentNode?.insertBefore(clone, element.nextSibling);
          if (clone.tagName === 'A' && clone.hasAttribute('href')) { clone.addEventListener('click', e => e.preventDefault()); clone.vheClickListenerAttached = true; }
          setTimeout(() => {
            element.classList.remove('vhe-element-duplicating'); clone.classList.remove('vhe-element-duplicating');
            clearElementSelection(); selectedElement = clone; selectedElement.dataset.vheElementSelected = 'true'; showElementToolbar(selectedElement);
          }, 400); addHistorySnapshot(`Cloned ${element.tagName}`);
        }, 50); return clone;
      } catch (error) { console.error("Error cloning:", error); alert("Failed to clone."); if (element) { element.classList.remove('vhe-element-duplicating'); } return null; }
    }
    function deleteSelectedElement(element) {
      if (!element || element === iframeDoc?.body) { alert("Cannot delete body."); return false; }
      const elementType = element.tagName; const wrapperLink = element.tagName === 'BUTTON' ? element.closest('a[data-vhe-link-wrapper="true"]') : null; const elementToDelete = wrapperLink || element;
      if (confirm(`Delete this ${elementType} element?`)) {
        try {
          elementToDelete.classList.add('vhe-element-deleting');
          setTimeout(() => {
            const parentDescription = elementToDelete.parentElement ? `parent ${elementToDelete.parentElement.tagName}` : 'unknown parent';
            elementToDelete.remove(); addHistorySnapshot(`Deleted ${elementType} from ${parentDescription}`); selectedElement = null; hideElementToolbar();
          }, 300); return true;
        } catch (error) { console.error("Error deleting:", error); alert("Failed to delete."); if (elementToDelete) { elementToDelete.classList.remove('vhe-element-deleting'); } return false; }
      } return false;
    }

     function updateHoverStyleTag(element, textColor, bgColor, duration) {
         if (!element || !iframeDoc) return; let elementId = element.dataset.vheElementId; if (!elementId) { elementId = `vhe-elem-${Date.now()}-${Math.random().toString(36).substring(2, 7)}`; element.dataset.vheElementId = elementId; }
         let hoverStyleTag = iframeDoc.getElementById(`vhe-hover-style-${elementId}`); const hoverActive = textColor || bgColor || duration;
         if (hoverActive) {
             if (!hoverStyleTag) { hoverStyleTag = iframeDoc.createElement('style'); hoverStyleTag.id = `vhe-hover-style-${elementId}`; iframeDoc.head.appendChild(hoverStyleTag); }
             if (textColor) { element.style.setProperty('--vhe-hover-text-color', textColor); } else { element.style.removeProperty('--vhe-hover-text-color'); }
             if (bgColor) { element.style.setProperty('--vhe-hover-bg-color', bgColor); } else { element.style.removeProperty('--vhe-hover-bg-color'); }
             element.style.setProperty('--vhe-hover-duration', duration || DEFAULT_HOVER_DURATION);
             let cssRules = `[data-vhe-element-id="${elementId}"] { transition-duration: var(--vhe-hover-duration, ${DEFAULT_HOVER_DURATION}) !important; } [data-vhe-element-id="${elementId}"]:hover {`;
             if (textColor) cssRules += ` color: var(--vhe-hover-text-color) !important;`; if (bgColor) cssRules += ` background-color: var(--vhe-hover-bg-color) !important;`; cssRules += ` }`;
             hoverStyleTag.textContent = cssRules;
         } else { hoverStyleTag?.remove(); element.style.removeProperty('--vhe-hover-text-color'); element.style.removeProperty('--vhe-hover-bg-color'); element.style.removeProperty('--vhe-hover-duration'); }
     }

    function moveBlock(blockElement, direction) {
      if (!blockElement || !blockElement.parentNode) return false; const parent = blockElement.parentNode; let sibling = null; let moved = false;
      if (direction === 'up') { blockElement.classList.add('vhe-moving-up'); sibling = blockElement.previousElementSibling; while(sibling && ['SCRIPT','STYLE','TEMPLATE','LINK','META'].includes(sibling.tagName)) { sibling = sibling.previousElementSibling; } if (sibling) { sibling.classList.add('vhe-moving-down'); setTimeout(() => { parent.insertBefore(blockElement, sibling); blockElement.classList.remove('vhe-moving-up'); sibling.classList.remove('vhe-moving-down'); }, 250); moved = true; } else { blockElement.classList.remove('vhe-moving-up'); } }
      else { blockElement.classList.add('vhe-moving-down'); sibling = blockElement.nextElementSibling; while(sibling && ['SCRIPT','STYLE','TEMPLATE','LINK','META'].includes(sibling.tagName)) { sibling = sibling.nextElementSibling; } if (sibling) { sibling.classList.add('vhe-moving-up'); setTimeout(() => { parent.insertBefore(blockElement, sibling.nextElementSibling); blockElement.classList.remove('vhe-moving-down'); sibling.classList.remove('vhe-moving-up'); }, 250); moved = true; } else { blockElement.classList.remove('vhe-moving-down'); } }
      if (moved) { setTimeout(() => { addHistorySnapshot(`Moved block ${direction}`); }, 300); return true; } return false;
    }
    function duplicateBlock(blockElement) {
      if (!blockElement || !blockElement.parentNode) return null;
      try {
        blockElement.classList.add('vhe-duplicating'); const clone = blockElement.cloneNode(true); clone.dataset.vheBlockId = `vhe-block-cloned-${Date.now()}`; delete clone.dataset.vheBlockHover; delete clone.dataset.vheElementHover; delete clone.dataset.vheElementSelected; clone.removeAttribute('contenteditable'); clone.querySelectorAll('[data-vhe-element-hover],[data-vhe-element-selected],[contenteditable="true"]').forEach(el => { delete el.dataset.vheElementHover; delete el.dataset.vheElementSelected; el.removeAttribute('contenteditable'); }); clone.classList.add('vhe-element-duplicating');
        setTimeout(() => { blockElement.parentNode.insertBefore(clone, blockElement.nextElementSibling); setTimeout(() => { blockElement.classList.remove('vhe-duplicating'); clone.classList.remove('vhe-element-duplicating'); }, 400); addHistorySnapshot(`Duplicated block`); }, 50); return clone;
      } catch (error) { console.error("Error duplicating:", error); alert("Failed to duplicate."); if (blockElement) { blockElement.classList.remove('vhe-duplicating'); } return null; }
    }
    function deleteBlock(blockElement) {
      if (!blockElement || blockElement === iframeDoc?.body || !blockElement.parentNode) return false;
      if (confirm("Delete this block?")) { try { blockElement.classList.add('vhe-deleting'); setTimeout(() => { blockElement.remove(); hideBlockToolbar(); if (hoveredBlock === blockElement) { hoveredBlock = null; } addHistorySnapshot(`Deleted block`); }, 300); return true; } catch (error) { console.error("Error deleting:", error); alert("Failed to delete."); if (blockElement) { blockElement.classList.remove('vhe-deleting'); } return false; } } return false;
    }

    function addHistorySnapshot(actionName = "Modified Content") {
        if (!iframeDoc || !iframeDoc.documentElement || currentContentLoading) return; clearElementSelection();
        setTimeout(() => {
            try {
                const snapshotDoc = iframeDoc.cloneNode(true);
                 snapshotDoc.querySelectorAll('[data-vhe-block-hover],[data-vhe-element-hover],[data-vhe-element-selected],[data-original-html],[contenteditable="true"]').forEach(el => { delete el.dataset.vheBlockHover; delete el.dataset.vheElementHover; delete el.dataset.vheElementSelected; delete el.dataset.originalHtml; el.removeAttribute('contenteditable'); });
                snapshotDoc.head?.querySelector('style[data-vhe-styles]')?.remove(); snapshotDoc.head?.querySelector('#vhe-google-fonts-link')?.remove();
                snapshotDoc.querySelectorAll('script[type="text/javascript"][data-vhe-disabled="true"]').forEach(script => { script.setAttribute('type', 'text/disabled-javascript'); });
                const doctypeString = iframeDoc.doctype ? new XMLSerializer().serializeToString(iframeDoc.doctype) : "<!DOCTYPE html>"; const fullSnapshotHtml = doctypeString + "\n" + snapshotDoc.documentElement.outerHTML;
                if (history.length > 0 && historyIndex >= 0 && history[historyIndex].html === fullSnapshotHtml) { console.log("History: No change detected."); return; }
                if (historyIndex < history.length - 1) { history = history.slice(0, historyIndex + 1); } history.push({ html: fullSnapshotHtml, action: actionName });
                if (history.length > MAX_HISTORY) { history.shift(); } historyIndex = history.length - 1;
                updateUndoRedoState(); console.log(`History (${historyIndex+1}/${history.length}): ${actionName}`);
            } catch (error) { console.error("History snapshot error:", error); }
        }, 50);
    }
    function addInitialHistorySnapshot() {
        history = []; historyIndex = -1; if (!iframeDoc || !iframeDoc.documentElement) { updateUndoRedoState(); return; }
        setTimeout(() => {
            try {
                const snapshotDoc = iframeDoc.cloneNode(true);
                 snapshotDoc.querySelectorAll('[data-vhe-block-hover],[data-vhe-element-hover],[data-vhe-element-selected],[data-original-html],[contenteditable="true"]').forEach(el=>{ delete el.dataset.vheBlockHover; delete el.dataset.vheElementHover; delete el.dataset.vheElementSelected; delete el.dataset.originalHtml; el.removeAttribute('contenteditable'); });
                snapshotDoc.head?.querySelector('style[data-vhe-styles]')?.remove(); snapshotDoc.head?.querySelector('#vhe-google-fonts-link')?.remove();
                const doctypeString = iframeDoc.doctype ? new XMLSerializer().serializeToString(iframeDoc.doctype) : "<!DOCTYPE html>"; const fullInitialSnapshotHtml = doctypeString + "\n" + snapshotDoc.documentElement.outerHTML;
                history.push({ html: fullInitialSnapshotHtml, action: "Initial Load" }); historyIndex = 0;
                updateUndoRedoState(); console.log("Initial history added.");
            } catch (error) { console.error("Initial history error:", error); updateUndoRedoState(); }
        }, 150);
    }
    function undo() { if (!canUndo() || currentContentLoading) return; console.log("Undo"); currentContentLoading = true; historyIndex--; restoreHistoryState(historyIndex); updateUndoRedoState(); }
    function redo() { if (!canRedo() || currentContentLoading) return; console.log("Redo"); currentContentLoading = true; historyIndex++; restoreHistoryState(historyIndex); updateUndoRedoState(); }
    function restoreHistoryState(index) {
      if (!iframe || index < 0 || index >= history.length) { console.error("Invalid history index/iframe:", index); currentContentLoading = false; return; }
      const state = history[index]; console.log(`Restoring history ${index}: ${state.action}`); clearElementSelection(); hideElementToolbar(); hideBlockToolbar(); clearBlockHover(); clearElementHover();
      iframe.onload = null; iframe.onerror = null;
      iframe.onload = () => {
        if (!currentContentLoading) { console.log("Restore aborted, loading flag false."); return; }
        try {
          iframeDoc = iframe.contentDocument; iframeWin = iframe.contentWindow; if (!iframeDoc || !iframeWin) throw new Error("Cannot access iframe content after restore.");
          iframeWin.requestAnimationFrame(() => {
            if (!iframeDoc.body) throw new Error("Iframe body not found after restore.");
            const success = instrumentIframeContent();
            if (success) console.log("Restored & instrumentation started (async)."); else { console.error("Failed re-instrumentation after restore."); showError("Error restoring state."); }
            currentContentLoading = false; updateUndoRedoState();
          });
        } catch (error) { console.error("Error during history restore setup:", error); alert("Error during undo/redo."); currentContentLoading = false; updateUndoRedoState(); }
      };
      iframe.onerror = (err) => { console.error("Iframe error during history restore:", err); alert("Failed to restore state."); currentContentLoading = false; updateUndoRedoState(); };
      iframe.srcdoc = state.html;
    }
    function canUndo() { return historyIndex > 0; }
    function canRedo() { return historyIndex >= 0 && historyIndex < history.length - 1; }
    function updateUndoRedoState() { if(undoBtn) undoBtn.disabled = !canUndo(); if(redoBtn) redoBtn.disabled = !canRedo(); }

     function saveAndExportHtml() {
         console.log("Save clicked..."); if (!iframeDoc || !iframeDoc.documentElement) { alert("No content to save."); return; }
         try {
           const finalHtmlToExport = getCurrentHTML(); const sourceUsed = 'getCurrentHTML';
           if (typeof finalHtmlToExport !== 'string' || finalHtmlToExport.length < 50) { throw new Error(`Generated HTML invalid (source: ${sourceUsed}).`); }
           console.log(`Generated HTML (source: ${sourceUsed}), length: ${finalHtmlToExport.length}.`);
           const blob = new Blob([finalHtmlToExport], { type: 'text/html;charset=utf-8' }); const url = URL.createObjectURL(blob); if (!url) { throw new Error("Failed create URL."); }
           const a = document.createElement('a'); a.href = url; let originalFilename = 'edited_page';
           try { if (fileInput?.files && fileInput.files.length > 0) { originalFilename = fileInput.files[0].name.replace(/\.(html|htm)$/i, ''); } } catch (e) { console.warn("Could not get filename.", e); }
           a.download = `${originalFilename}_edited.html`; console.log(`Prepared download: ${a.download}`);
           document.body.appendChild(a); a.click(); console.log("Click triggered."); document.body.removeChild(a); URL.revokeObjectURL(url); console.log("Export successful.");
         } catch (error) { console.error("Export error:", error); alert(`Could not export. Error: ${error.message}\nCheck console.`); }
     }

  </script>
</body>
</html>